LABTITLE=: 'An Introductory Course in J'
LABAUTHOR=: 'Henry Rich'
LABCOMMENTS=: 'Lecture notes from a 3-day class on J.'
LABERRORS=: 1
LABWIDTH=: 80
LABWRAP=: 0
LABFOCUS=: 1

NB. ============================================================================
Lab Chapter Introduction to J
NB. ============================================================================
Lab Section Why J?
J is not primarily a computer language.  It is not a way for you to describe
things in terms that are easy for a computer to understand.

J is a language of computation.  J allows you to express your computational
ideas concisely.

You have the immense good fortune to be able to type J into a computer and
have it perform the computation for you.

When you type a J sentence, the computer evaluates it and displays the
result.
)
2 + 3   NB. Computer evaluates the sentence
i. 5  NB. Computer evaluates the sentence, producing a list of numbers
i. 3 5   NB.  Result of this sentence is an array of numbers

NB. ============================================================================
Lab Section J Is Weakly Typed
J has no declarations.

You may assign the result of any expression to a name and subsequently
refer to the name.  The name will hold the value assigned, which may
be a number, a character, an array, or a program.

Since names can refer to any kind of entity, and can be reassigned at will,
J is implemented with an interpreter.
)
a =: i. 2 3  NB. Assign a value to a
a  NB. look at it
b =: '6 + a'   NB. Create a character string
b  NB. look at it
". b  NB. Execute it!

NB. ============================================================================
Lab Section The Vocabulary of J Documentation
'Programs' and 'data' are not fundamental ideas in J, since as we have seen
what looks like data can sometimes be executed.

J uses a different terminology, one more suited to its concepts.  The terms
are borrowed from English grammar but they are given precise new meanings
in J.

VERB is the name for a program.

NOUN is the name for data, anything from a number to an array.

ADVERBs and CONJUNCTIONs (collectively called MODIFIERs) modify the
behavior of verbs and nouns in specified ways.  Modifiers are what give
J its expressive power.

All things in J, called ENTITIES, are one of the four principal parts of
speech (verb, noun, adverb, conjunction).
)

NB. ============================================================================
Lab Section Nouns Carry Type and Size Information
When you refer to a noun by its name, you are automatically referring to all
of it, whether it is an array or a single item.

The dimensioning of the noun (called its SHAPE) is included as part of
the noun, and you can use J's facilities to inquire about it if you need to.
)
a =: i. 2 3  NB. Create an array
a  NB. Look at it
$ a  NB.  The $ verb gives the shape of its operand
$ 'there is a tide'  NB. The character string is an array.  What is its shape?

NB. ============================================================================
Lab Section Verbs Automatically Operate On Arrays
You can ask J about the dimensioning of an array using $, but the
really great thing about J is that you seldom have to.

Every verb, including verbs you write, can be applied automatically
to an entire array.  The verb + means 'add'.  a + b  is the sum of
a and b, whether a and b are single numbers or arrays.

J has many different ways to generalize the way your verb is applied to an
array.  By selecting the proper forms, you can get the effect of
program loops without having to write loops by hand.
)
a =: i. 2 3   NB. Create an array
a  NB. Look at it
a + 4   NB. Add 4 to it - result is a new array
b =: a + 4  NB. Assign that new array to a name
a * b  NB. Multiply a and b, element by element.

NB. ============================================================================
Lab Section Monadic and Dyadic Verbs
Every verb in J has two forms: MONADIC, where it has one operand,
as in  - 5, and DYADIC, where it has two operands, as in 6 - 5.

This applies to verbs you write as well as J's internal primitives.

If a verb has nouns to its left and right, it will be executed in the
dyadic form; if it has a noun only to its right, it will be executed in
the monadic form.
)
>. 4.5   NB. Monadic >. means 'next higher integer'
5.5 >. 4.5   NB. Dyadic >. means 'pick the larger operand'
5 + 5.5 >. 4.5

NB. ============================================================================
Lab Section No Operator Precedence; Right-to-Left Execution
Since all verbs, both J's primitives and the ones you write, are
executed with the same syntax (name with one or two operands), it
is impossible to give a list of operator precedence, such as the
usual mathematical rules of multiplication before addition.  If you
write a verb to multiply, how is the system to give it priority over a verb
for addition?

So, J has the simplest possible rule: verbs are executed right to left.

Modifiers have a slightly more complex rule that we won't get into now.
)
NB. We can use parentheses to indicate the execution order.
1 + 2 + 3
1 + (2 + 3)
1 - 2 + 3
1 - (2 + 3)   NB. What part of 'right to left' didn't you understand?

NB. ============================================================================
Lab Section Modifiers Extend Verbs
Modifiers change the way verbs operate.

+ is a verb.  / is an adverb.  So is \  .

An  adverb is written after a verb to create a modified verb.

So,

+/   is a new verb
+\   is a new verb
+/\  is a new verb

You can see that a vast number of programs can be written with just a few
keystrokes.
)
NB. The definition of u/ (where u is a verb) says that when it
NB. is used dyadically, it creates a table:
(0 1 2 3) +/ (0 1 2 3)   NB. Create an addition table
NB. The same modifier can be applied to a different verb to create a
NB. table for that verb
(0 1 2 3) */ (0 1 2 3)   NB. Create a multiplication table
myverb =: dyad : '2 * x >. y'"0  NB. Create a custom verb: 'double the larger'
(0 1 2 3) myverb/ (0 1 2 3)  NB. Modifier applies to user-written verbs too

NB. ============================================================================
Lab Section J's Data Types: Numbers
The primary data types in J are NUMBERs and CHARACTERs.

Numbers can be Boolean, integer, floating-point, complex, or exact.

Exact numbers are either extended-precision integers, which are as long
as necessary to hold the number exactly, or rational numbers which are
fractions whose numerator and denominator are extended-precision integers.

You generally don't have to trouble yourself about what kind of number
you have.  J will use whatever kind of number it needs to and you will
get the correct result.
)
2 ^ 50x  NB. 50x is an extended integer, so this gets an extended result
%: 16   NB. %: means square root
%: -2  NB. Square root of a negative number is complex
2 % 3x  NB. % means 'divide'.  2r3 is a rational number, 2 divided by 3
2r3 - 1r2  NB. 2/3 - 1/2 = 1/6, but there's no roundoff.  The numbers are exact

NB. ============================================================================
Lab Section Numbers: The Iverson Convention
Boolean truth values, such as the results of conditionals, are
the ordinary numbers 0 (for false) and 1 (for true).  These Boolean
values can be used just like any other numbers.

Treating truth values as numbers is known to computer scientists as the
Iverson Convention, after its inventor Kenneth Iverson, who is also the
originator of J and APL.
)
NB. The verb +/, when used as a monad, adds up a list.  Think of it as Sum.
Sum =: +/  NB. Give the verb a name
Sum 1 2 3
Sum 1 2 3 4
NB. How would you find out how many items of a list are greater than 4?
Sum 4 < 3 1 4 1 5 9  NB. Just add the truth values
4 < 3 1 4 1 5 9  NB. This is the list of truth values

NB. ============================================================================
Lab Section J's Data Types: Characters
Character strings are enclosed in single quotes.

A character string is automatically an array.
)
a =: 'there is a tide'  NB. A character string
a   NB. Show its value
$ a  NB. Show the shape of the array
+/ 'e' = a  NB. How many occurrences of 'e' are in the array?

NB. ============================================================================
Lab Section J's Data Types: Others
J has data types other than numbers and characters, but we will not
go into detail about them here.

UNICODE characters are a data type, as are SYMBOLs (which refer to character
string for high performance and BOXes (which hold other noun, possibly
including other boxes).
)
< 1 2 3   NB. Put a noun in a box
a =: < 1 2 3
$ a   NB. Show the shape of a
NB. Note that the shape is a blank line, denoting an empty list.  That means
NB. it has no axes, in other words it is a scalar.  Its contents are a list,
NB. but the box itself is a scalar.
<\ 1 2 3 4 5   NB. Create a list of boxes

NB. ============================================================================
Lab Section Surprises
There are a few basic things about J that may surprise you:

1.  Period and colon are INFLECTIONs that are suffixed to names to make
  new names.  + +. +: and +:: are all different names.

2.  The only punctuation is control statements (if. for example) and
     ( ) ' NB. LF

  LF (end-of-line) is the only end-of-sentence sentence delimiter

  NB. starts a comment.  Everything on a line after NB. is ignored

3.  { } [ ] " ,  are NOT punctuation, and are NOT paired - they are
  individual symbols with defined meanings

4.  A sequence of numbers separated by spaces is taken as a single list of
  numbers.  This is NOT true for names separated by spaces.
)
NB. The following is a perfectly good sentence.  The verb { means
NB. 'select', so the verb is selecting item number 2 from the list
NB. 1 2 3 4 5
2 { 1 2 3 4 5

NB. ============================================================================
Lab Chapter Arrays
NB. ============================================================================
Lab Section What Is An Array?
An ARRAY is a noun that contains a number of VALUES each of which is
identified by a numerical INDEX.

All the values in an array must have the same TYPE: numeric, literal
(character), or boxed.  There are some other exotic types that we
will not use.

An array may have any number of dimensions.

The value of an array, which is seen when you type the name, consists
of all its values.  Values are displayed starting with the element with
index 0, followed by the other elements in order.  After the last
element along a dimension has been displayed, a linefeed is typed,
the index of that dimension is set to 0, and the next-larger dimension
is advanced.

Following this rule, you can see that the number of spaces between
lines can be used to keep track of what index is wrapping around to 0.
)
i. 3 4  NB. A 3x4 array
i. 2 3 4  NB. A 3-dimensional array.  Note the extra space between 3x4 sections
i. 2 2 2 2  NB. A 4-dimensional array.  Note the spacing

NB. ============================================================================
Lab Section Terms: Axis, Shape, Rank, Atom, Scalar, Vector, Table, Empty
Each dimension of an array is called an AXIS.

The number of axes in an array is its RANK.

An array of rank 0 is called an ATOM or a SCALAR.  It has no axes and therefore
no indexes, and it has exactly one value.

An array of rank 1 is called a VECTOR.

An array of rank 2 is called a TABLE.

An array with no atoms is said to be EMPTY.

Identifying an element of the array means specifying the value of an index
for each axis.  The indexes run from 0 to (the length of the axis minus 1).
In other words, 0-origin indexing is used.

The axes are ordered such that the implied order of the elements, revealed
when they are typed or turned into a single vector, comes by varying the LAST
axis fastest.  In other words, row-major order is used.

The vector of the lengths of the axes, ordered first axis to last, is called the
SHAPE of the array.  The shape of any noun is a vector.

The length of the shape is the rank.

Every empty array has a 0 somewhere in its shape.
)
NB. $ shows the shape of a noun:
]p =: i. 2 3  NB. A 2x3 array
$p  NB. The shape of the array
$ 0 1 2 3 4 5   NB. A list with 6 elements.  Shape is 6

NB. NOTE THE DIFFERENCE BETWEEN AN ATOM AND A VECTOR OF LENGTH 1:
]p =. i. 1   NB. A list with 1 element
$ p   NB. Shape is 1
1  NB. An atom
$ 1  NB. Shape is an empty vector

$ 'abc'  NB. A character string
$ 'a'  NB. Note that a single character constant is an atom
$ ,'a'  NB. This is a character vector of length 1

NB. ============================================================================
Lab Section Terms: Cell, Frame
A k-CELL of an array A is a subarray of A made up of all the values
of the array whose indexes differ only in the last positions.  The rank of
a k-cell is k, and the shape of a k-cell of A is the last k elements of the
shape of A.

The part of the shape of A remaining after discarding the last k elements
of the shape is called the k-FRAME of A.  (Also called the frame of A with respect
to k-cells)

For any k, (the k-frame of A) concatenated with (the shape of a k-cell of A)
is the shape of A.

An array can be interpreted as an array of its k-cells.  The k-frame of the array
is the shape of this array of k-cells.

For k larger than the rank of A, the k-cell of A is the entire A and the k-frame
is empty.  A k of _ (infinity) is allowed.
)
NB. We will use a 2x2x3 array for demonstration:
a =: i. 2 2 3

NB. The verb <"k boxes k-cells, leaving an array of boxes whose shape is the
NB. k-frame.  The shape inside each box is the shape of the k-cell.
]b0 =: <"0 a  NB. Boxing 0-cells (atoms)
$ b0   NB. 0-frame of a
$ > {. , b0  NB. Shape of a 0-cell (empty)

]b1 =: <"1 a  NB. Boxing 1-cells
$ b1   NB. 1-frame of a
$ > {. , b1  NB. Shape of a 1-cell

NB. ============================================================================
Lab Section
A k-CELL of an array A is a subarray of A made up of all the values
of the array whose indexes differ only in the last positions.  The rank of
a k-cell is k, and the shape of a k-cell of A is the last k elements of the
shape of A.

The part of the shape of A remaining after discarding the last k elements
of the shape is called the k-FRAME of A.  (Also called the frame of A with respect
to k-cells)

For any k, (the k-frame of A) concatenated with (the shape of a k-cell of A)
is the shape of A.

An array can be interpreted as an array of its k-cells.  The k-frame of the array
is the shape of this array of k-cells.

For k larger than the rank of A, the k-cell of A is the entire A and the k-frame
is empty.  A k of _ (infinity) is allowed.
)
]b2 =: <"2 a  NB. Boxing 2-cells
$ b2   NB. 2-frame of a
$ > {. , b2  NB. Shape of a 2-cell

]b3 =: <"3 a  NB. Boxing 3-cells
$ b3   NB. 3-frame of a (empty)
$ > {. , b3  NB. Shape of a 3-cell

NB. ============================================================================
Lab Section Negative Cell Rank.  Items
If k is negative, a k-cell of A is defined to be a max(0,(rank of A)+k)-cell of A.
In other words, the k-FRAME, for negative k, comprises the (-k) leading elements
of the frame of A, and the shape of the k-cell comprises any elements of A
left over after the first (-k) are removed.

A _1-cell of A is called an ITEM of A.

An atom has 1 item, itself.  (Memorize this phrase!)
)
NB. The # verb produces the number of items in its operand:
# i. 2 3 4  NB. A 2x3x4 array has 2 items, each a 3x4 array
# 1 2 3 4  NB. A 4-item vector
# 0  NB. A scalar has 1 item (itself)
# ''  NB. An empty vector has no items
# i. 3 0 4  NB. An empty array may have items: 3 items each a 0x4 array

NB. # $ y   gives the rank of y.  The rank is the length of the shape
# $ i. 2 3 4  NB. A rank-3 array
# $ i. 2 2 2 2 2 2  NB. A rank-6 array

NB. */ $ y  gives the number of atoms in y
*/ $ i. 2 3 4   NB. A 2x3x4 array
*/ $ i. 3 0 4  NB. An empty array
*/ $ 4   NB. An atom has one atom, itself

NB. ============================================================================
Lab Section Noun Shape = Frame Concatenated With Cell Shape
Remember, a noun's shape is an array containing the lengths of its axes.

When you view a noun as k-cells, you are splitting the noun's shape into two
parts: the last k items of the shape are the shape of the cell, and any
leftover beginning items are the frame with respect to k-cells.

So, the frame concatenated with the cell shape always recovers the shape of
the noun.

Consider a noun with shape 2 3 4 5.

k      k-cell      k-cell         Comment
       frame       shape
------------------------------------------
0      2 3 4 5     (empty)     2x3x4x5 shaped group of scalars (atoms)
1      2 3 4       5           2x3x4 array of 5-atom vectors
2      2 3         4 5         2x3 table of 4x5 tables
3      2           3 4 5       two 3x4x5 arrays
4      (empty)     2 3 4 5     a single 2x3x4x5 array

_1     2           3 4 5       two 3x4x5 arrays
_2     2 3         4 5         2x3 table of 4x5 tables
_3     2 3 4       5           2x3x4 array of 5-atom vectors
_4     2 3 4 5     (empty)     2x3x4x5 shaped group of scalars (atoms)
)
rank4array =: i. 2 3 4 5
$rank4array
b1 =: <"1 rank4array  NB. Boxing 1-cells
$ b1   NB. 1-frame of rank4array
$ > {. , b1  NB. Shape of a 1-cell

NB. ============================================================================
Lab Section Lists
A non-atomic array A can be thought of as an array, of length #A, of its items.
We say that A is a LIST, with length #A, of its items.

A list of atoms is called simply a LIST.  What we have heretofore called a vector
is normally called a list.


The J term 'list' has nothing to do with linked lists.
)
<"_1   i. 3 4 5  NB. The array is a list of 3 items, each a 4x5 array

NB. ============================================================================
Lab Section Examples
The next example creates and displays a 3D array, and assumes that OpenGL is available on your system.
If it is not, the displays shown are the J defaults.

We will use as a test array a 10x10x10 array m representing a volume containing
10 randomly-placed objects.  The coordinates of the objects are the 10x3 array
p.  Each object contributes to an atom of m according to the Manhattan distance
between the object and the atom: 3 for the atom containing the object, 2
for the 6 immediate neighbors, 1 for 18 neighbors at distance 2.

The next section tests to see if your system supports OpenGL.
)
PREPARE
require :: ] 'opengl'
coinsert 'jzopenglutil'
testdlls=: 3 : 0
try.
 ogl=.''conew'jzopengl'
 alloc__ogl 4 4
 destroy__ogl''
 IFOPENGL_z_=: 1
 'OpenGL OK.'
catch.
 IFOPENGL_z_=: 0
 'OpenGL create context failed. OpenGL not available.'
end.
)
PREPARE
] p =: ? 10 3 $ 10  NB. Create the random positions
] m =: (< p) +/@:((0 >. 3 - [: +/ |@:-)"1)&> { 3 $ < i. 10  NB. Fill the array

NB. ============================================================================
Lab Section
Testing for OpenGL...
)
testdlls''

NB. ============================================================================
Lab Section
We will display a 3D view of the array, with coloring to indicate
the nonzero values.

Each cube is a 0-cell of the array.

If OpenGL is not available, just step to the next section.
)
PREPARE
require :: ] 'opengl'
coinsert 'jzopenglutil'

gsetdefaults :: ] ''

OPENGL=: 0 : 0
pc opengl;
xywh 0 0 400 400;cc g isigraph opengl rightmove bottommove;
pas 0 0;
rem form end;
)

showm=: 3 : 0
if. -. IFOPENGL do. y return. end.
posxl =. 0.2 0.2 _0.2 (*"1) _4.5 _4.5 0.1 +"1 ]
'm box' =. y
cubenormals =. gsunitnormal cubefaces =. 0.03 gscubeface''
xl =. posxl (#: i.@(*/)) 10 10 10
xl =. (0 ~: ,m) # xl
m =. (0 ~: ,m) # ,m
f =: (,/) cubefaces +"1"2 1 (12) $"1 xl
n =: ((#cubenormals) * #xl) $ cubenormals
c =: 6 # 2 2 2 #: m
objs =: f;n;c
if. #box do.
v=. #:i.8
n=. _2[\0 1 0 2 0 4 1 3 1 5 2 3 2 6 3 7 4 5 4 6 5 7 6 7
e=. n{v
'll ur' =. box
boxs =: ,"2 posxl ll +"1 (ur-ll) *"1 e
else.
boxs =: $0
end.
if. wdisparent 'opengl' do.
wd 'psel opengl'
paint''
else.
wd OPENGL
ogl=: '' conew 'jzopengl'
end.
wd'pshow;'
)

opengl_close=: 3 : 0
destroy__ogl''
ogl=: ''
wd 'pclose'
)

opengl_cancel=: opengl_close

NB. basic demo 3, with 2 objects
NB.
NB. use the i/o keys to move out so that
NB. both objects are fully visible

paint=: 3 : 0
gsinit''
glPushMatrix''
glRotate 10 1 1 1
gsdrawsolid objs
if. #boxs do.
gsdrawlines boxs;'';1 1 1
end.
glPopMatrix''
NB. gsdrawdodecahedron ''
NB. glTranslate 1.5 0 0
NB. gsdrawicosahedron''
gsendlist''
gsfini''
)

opengl_g_paint=: paint
opengl_g_char=: gschar
opengl_default=: gsdefault

3 : 0''
if. -. IFOPENGL do. i.0 0 return. end.
try.
  ogl=. ''conew'jzopengl'
  alloc__ogl 4 4
  destroy__ogl''
catch.
  wdinfo 'OpenGL';'OpenGL create context failed. OpenGL not available.'
end.
)

PREPARE
showm m;''

NB. ============================================================================
Lab Section
We draw a box to illustrate a 1-cell.

The 1-cell is a strip of 10 cubes.  The other 1-cells are in lines parallel
to the one indicated.

The language facilities of J make it easy to refer to cells.  So, in this
array it will be easy to execute operations within horizontal strips, and
slightly less easy to operate on, say, vertical strips.
)
showm m;_0.3 _0.3 _0.3 ,: 9.3 0.3 0.3

NB. ============================================================================
Lab Section
We draw a box to illustrate a 2-cell.

The 1-cell is a plane of 100 cubes.  The other 2-cells are in planes parallel
to the one indicated.

The language facilities of J make it easy to refer to cells.  So, in this
array it will be easy to execute operations within properly oriented planes.
)
showm m;_0.3 _0.3 _0.3 ,: 9.3 9.3 0.3

NB. ============================================================================
Lab Chapter Rank of Verbs
NB. ============================================================================
Lab Section Review of Terms
An n by m by ...   array has the SHAPE n,m,...
The shape of a noun is a vector, with one number per dimension.

  The shape of a noun is given by $ noun

The number of dimensions of the array is its RANK

  The rank of a noun is given by #@$ noun

An array with rank 0 is an ATOM, also called a SCALAR.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
$ array  NB. shape
#@$ array  NB. rank

NB. ============================================================================
Lab Section
An array can be interpreted as an array of CELLS each of which
  is an array of the same rank and shape.  For example, a 2x3x4 array
  can be interpreted as:
    A 2x3x4 array of cells of rank 0 (atoms)
 or A 2x3 array of cells of rank 1 (each cell has shape 4)
 or An array of 2 cells of rank 2 (each cell has shape 3x4)
 or A single entity of shape 2x3x4.

If k is greater than or equal to the rank of the array, there is a single
  k-cell, containing the entire array.

Cells with rank k are called K-CELLS.

  The shape of the k-cells of a noun is given by
    k ((] {.~ [: - (<. #))  $) noun

When the array is viewed as an array of shape j of k-cells, j is called
  the FRAME of the array with respect to k-cells, or the K-FRAME of the array.

  The 1-frame of a 2x3x4 array is  2 3 .

  The k-frame of a noun is given by
    k ((] }.~ [: - (<. #))  $) noun
)
array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
cellshape =: ((] {.~ [: - (<. #))  $)
cellframe =: ((] }.~ [: - (<. #))  $)
1 cellshape array
1 cellframe array
NB. Different interpretations of the array:
('Frame';'Cell Shape') , 0 1 2 (cellframe ; cellshape)"0 _  array

NB. ============================================================================
Lab Section
The notion of k-cells can be expanded to negative values of k.  The
(-k)-CELLS of a noun have rank k less than the rank of the noun.

   The _1-cells of a 2x3x4 array have rank 1 less than the array, in other
   words rank 2, shape 3 4 .

The _1-cells of a noun are called the ITEMS of the noun.


An array is said to be a LIST of its items.  The 2x3x4 array is a list of
  2-cells, each of which has shape 3 4.

   The number of items in a noun is given by # noun


A list of atoms is called a LIST.


An atom has one item, which is the same as the atom itself.
)
array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
$ array
#array
$ 5  NB. A scalar has no dimension, so the shape of a scalar is an empty list
#@$ 5   NB. Rank of a scalar is 0
# 5  NB. A Scalar has one item

NB. ============================================================================
Lab Section Monadic Verb Rank
Every verb has two RANKS, one for the monadic case and one for dyadic.
We will discuss monads here.

When a verb v with rank r is applied to a noun n, the noun is
  viewed as an array of r-cells.  Call the r-frame of n  f; then n
  is viewed as an array, of shape f, of r-cells.  v is applied to each
  r-cell independently, and the result is viewed as an array of shape
  f of cells, where each result cell comes from the application of v to a
  single cell of n.

The " conjunction can be used to make a verb with a desired rank.
  v"n is a verb with rank n.  It applies v to each n-cell of its operand.

v b. 0 shows the ranks of v.  The first number is the monadic rank.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
# b. 0  NB. Infinite rank - applies to the entire array
# array
#"2 b. 0   NB. Rank of #"2 is 2
#"2 array  NB. Applies # to each 2-cell.  There are 2 of them.
#"1 array  NB. Applies # to each 1-cell.  They make up a 2x3 array
#"0 array  NB. Applies # to each atom, a 2x3x4 array

NB. ============================================================================
Lab Section Shape of the Result
The shape of the overall result is the r-frame of the operand, concatenated
with the shape of the result for an individual cell.

Stop now and reread that until you thoroughly understand it.
)
](array2 =: 3 2 4 $, array) ; array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
($array2) ; ($array)  NB. array2 has shape 3 2 4, array has shape 2 3 4
NB. The verb {. means 'take the first item'.
NB. {."1 means 'apply {. on 1-cells'
NB. Each application of {. in the following two sentences
NB. produces an atom, rank=0.  The 1-cells of array and array2 are
NB. the same, but they have different 1-frames.  The results are displayed
NB. side-by-side:
({."1 array2)  ;  ({."1 array)
NB. Shape of result is 1-frame concatenated with cell-result shape (which is empty)
($ {."1 array2) ;  ($ {."1 array)
NB. The verb 2&{. means 'take the array consisting of the first two items'
NB. 2&{."1 means 'apply 2&{. on 1-cells'
NB. Each application of 2&{. produces a list, rank=1, shape=2.  The 1-cells
NB. of array and array2 are the same, but they have different 1-frames
(2&{."1 array2)  ;  (2&{."1 array)
NB. Shape of result is 1-frame concatenated with cell-result shape (2)
($ 2&{."1 array2) ;  ($ 2&{."1 array)

NB. ============================================================================
Lab Section Framing Fills
The shape of the overall result is the r-frame of the operand, concatenated
with the shape of the result for an individual cell.

But what happens if the results for the individual cells have different
  shapes?

In that case, the results are brought up to the same size by adding
  padding to the shorter results.  This padding is called FRAMING FILL,
  and it is 0 for numbers, ' ' for characters, or a: for boxes.

If the results have different rank, first they are brought up to the
  same rank by adding leading axes of length 1; then fill is added.
)
] array =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
NB. The spaces are framing fills:
(-.&'abe')"1 array  NB. -.&'abe' removes the letters a, b, and e
#@(-.&'abe')"1 array  NB. the length of each intermediate result

NB. ============================================================================
Lab Section Dyadic Verb Rank
Each verb has a rank when used dyadically.  This is two numbers: the
  rank used on the left operand and the rank used on the right operand.

v b. 0 shows the ranks of v.  The second number is the left rank,
  the last is the right rank.

When the verb v is applied dyadically, as in x v y, each operand has
  a frame, called the LEFT FRAME and the RIGHT FRAME.

When the left frame and the right frame are identical, it means that
  there is a one-to-one correspondence of cells between the left and the
  right operands.  In that case the verb v is applied between each
  corresponding pair of cells, producing an independent result for each
  pair.  These results are then treated as an array of cells whose
  frame is the same as the frame of the operands.
)
array
]selector =: 2 3 $ 0 1 2 0 1 3
{"0 1 b. 0  NB. Left rank of {"0 1 is 0, right rank is 1
0 cellframe selector  NB. Left and right frames are identical
1 cellframe array
selector {"0 1  array  NB. Each number selects a character from a list
$ selector {"0 1  array
selector {."0 1  array  NB. Each number creates a vector of that length
$ selector {."0 1  array

NB. ============================================================================
Lab Section
When the left and right frame are not identical, the situation becomes
  more complicated.

For an operation to be possible, the shorter frame must be a prefix
  of the longer.  Failure to meet this condition produces a length error.
)
i. 2 3   NB. A 2x3 array
100 101 102 + i. 2 3   NB. length error - why?

NB. The rank of the verb is 0 0.  The left frame is 3; the right frame is 2 3;
NB. 3 is not a prefix of 2 3; error.

100 101 + i. 2 3  NB. Left frame 2, right frame 2 3, 2 is a prefix of 2 3; OK
100 101 102 +"1 i. 2 3  NB. Left frame empty, right frame ,2; empty is a prefix of ,2; OK

NB. ============================================================================
Lab Section
The shorter frame, which is a prefix of the longer, is called the
  COMMON FRAME.  The part of the longer frame that is left after the
  common frame is removed is called the SURPLUS FRAME.

The operand with the shorter frame is viewed as an array of operand
  cells whose shape is the common frame.  This is the same as the monadic
  case we discussed previously.

The operand with the longer frame is viewed as an array of subarrays, where
  each subarray is an array of operand cells whose shape is the surplus frame.
  The operand is an array of these subarrays, with shape equal to the common
  frame.

Each cell of the shorter-frame operand is matched with the corresponding
  subarray of the longer-frame operand.  The verb is applied between
  the shorter-frame cell and each cell in the longer-frame subarray.
  The results of the individual applications of the verb are collected into an
  array using the longer frame.

  You may think of each individual cell of the shorter-frame operand as
  being duplicated to make up for the surplus frame of the corresponding
  part of the longer-frame operand.
)
100 101 + i. 2 3  NB. left frame 2, right frame 2 3, common frame 2, surplus 3
array
NB. left frame empty, right frame 2 3, common empty, surplus 2 3
NB. cell result shape empty, overall result shape 2 3
2 {"1 array
NB. left frame empty, right frame 2, common empty, surplus 2
NB. cell result shape 4, overall result shape 2 4
2 {"2 array
NB. left frame 2, right frame 2 3, common 2, surplus 3
NB. cell result shape empty, overall result shape 2 3
0 2 {"0 1 array
NB. left frame 2, right frame 2, common 2, surplus empty
NB. cell result shape 4, overall result shape 2 4
0 2 {"0 2 array

NB. ============================================================================
Lab Section
Of course, just having the frames of the operands match does not guarantee
that the operation can be performed.

The resulting cells must also be valid for the verb they are passed into.
)
NB. The following line fails because there are two layers of verb: +"1 is
NB. the outer layer.  It matches up the left-side 1-cell (100 101) with each
NB. right-side cell, and passes those pairs to the inner verb which is +  .
NB. But + cannot add lists of different lengths, and it fails.
NB.
NB. The error does come from a mismatch of frames, but it is a mismatch
NB. in the operands to +  , not the operands to +"1 .
100 101 +"1 i. 2 3
NB. With a verb that can handle differently-shaped operands, like ,
NB. instead of + , the operation succeeds.
100 101 ,"1 i. 2 3
NB. The inner verb can fail for other reasons too, not just agreement:
NB. (here the problem is that 100 101 {. y expects a table for y)
100 101 {."1 i. 2 3

NB. ============================================================================
Lab Section Nested Rank Specification
The rank operator produces implicit looping.  You can nest rank
operators to produce nested loops.

In the verb u"r"s, the verb is executed as (u"r)"s; in other
  words, the operand cells are matched up using the shape s;
  then, within each corresponding pair of cells, subcells are
  matched up according to the shape r.
)
NB. Execution of  100 200 +"0"0 1 (1 2 3 4) :
NB. First, the rank 0 1 is used.  The left operand has the longer
NB.   frame, with surplus frame 2; cells of the right operand are replicated
NB.   accordingly.  There is only one right-operand cell, 1 2 3 4
NB. Then, +"0 is executed between each cell of the left operand
NB.   (which has rank 0) and each cell of the right operand (which has
NB.   rank 1); this causes the left-operand cells to be replicated.
100 200 +"0"0 1 (1 2 3 4)
NB. The intermediate step can be seen by displaying the operands to +"0 :
100 200 (<@;)"0 1 (1 2 3 4)
NB. The operands as they are matched before the final addition:
100 200 (<@;)"0"0 1 (1 2 3 4)

NB. ============================================================================
Lab Chapter Boxed Data
NB. ============================================================================
Lab Section The Boxed Data Type
The BOX is one of J's basic data types, along with literal and numeric.
A single box is an atom (aka scalar).  An array can have the boxed
data type, in which case each atom in the array is a box.

A box has CONTENTS, which can be any noun.  The contents of a box
can be an array, even an array of boxes; you can create a nesting
doll of boxes within boxes, as many layers as you want.

When you display a boxed noun, the box is drawn around the contents using
line-drawing characters.

A noun is said to be BOXED or UNBOXED.  OPEN is used as a synonym for
UNBOXED.  The term 'boxed list' is ambiguous: does it mean a list
that has been put into a box, or a list of boxes?  We will say here
that a 'boxed list' is a list that has been put into a box, and a
'list of boxes' is a list each of whose items is a box.  This terminology
is not standardized in J documentation.
)

NB. ============================================================================
Lab Section Creating Boxes: < (Box) and > (Open)
< y  creates a single (scalar) box whose contents are y.

Monad < has infinite rank, since you can put anything into a box.
)
<'abc'   NB. A single box
< i. 2 3  NB. A box containing an array
<"0 i. 2 3  NB. Box each atom, giving a 2x3 array of boxes
<"1 i. 2 3  NB. Box each list, giving a 2-item list of boxes
(< 0 1) , (< 2 3 4 5)  NB. Contents of boxes are independent
(<0 1) , (<'abc')
< (<0 1) , (<'abc')  NB. A boxed list can be boxed again

NB. ============================================================================
Lab Section
> y  opens a box, giving the contents of y.

Monad > has rank 0, since boxes are independent and you want to open each
one individually.
)
>  <'abc'   NB. Opening a box returns its contents
>  <"1 i. 2 3
NB. The boxes were opened independently, giving 2 lists, which were
NB. then assembled into an array.
> (< 0 1) , (< 2 3 4 5)  NB. Note that the assembly into an array may add fills
> (<0 1) , (<'abc')  NB. In fact, it may not even be possible
NB. A single array containing characters and numbers is not allowed, so the
NB. attempt to create one failed

> 1 { (<0 1) , (<'abc')   NB. 1 {   selects just box 1 which can be opened

NB. ============================================================================
Lab Section Creating Boxes: ; (Link)
x ; y  creates a boxed list out of x and y.  x is always boxed; y is
boxed only if it is not boxed already, then x and y are concatenated
into a list.

This asymmetrical definition causes an expression like

  x ; y ; z

to box each operand exactly once if they were all unboxed initially.
This is usually what you want.  If z was boxed, and you want to add
a boxing level to it too, you must write

  x ; y ;< z

to force boxing of the last item in the chain.

If you just want to add one level of boxing regardless of the initial
condition, use

  x ,&< y
)
1 ; 2 3 ; 4 5   NB. Create a list of boxes
1 ,&< 2 3 ,&< 4 5   NB. ,&< is not usually what you want
(1 ; 2) ; (3 4 ; 4 5)  NB. Do you expect 2 boxes or 3?
(1 ; 2) ,&< (3 4 ; 4 5)  NB. One way to get 2 boxes
(1 ; 2) ;< (3 4 ; 4 5)  NB. Another way

NB. ============================================================================
Lab Section Words  ;:
;: y  operates on a literal y to produce a boxed list with the words of
y in separate boxes.

The definition of 'word' is the one J uses for parsing sentences.  This
has all of the quirks of J syntax, but you may find it useful.

If you want to split a list into words separated by a delimiter
character, use

  <;._1 delimiter,string

Other partition functions can also be used to parse strings.
)
;: 'this is a sentence'
;: 'testing 1 2 3  numeric list is 1 word;  NB. a comment is a single word'
;: 'Period is an inflection.  When not preceded by space .'
;: 'mismatched quotes aren''t allowed'

<;._1  ' ','mismatched quotes aren''t allowed'

NB. ============================================================================
Lab Section Test Boxing Level  L.
L. y tells you the boxing level of y.
)
L. i. 2 3  NB. 0 means unboxed
L. < i. 2 3  NB. boxed once...
L. < < i. 2 3  NB. ...twice...
L. < < < i. 2 3  NB. ...three times

>^:L.   < < < i. 2 3  NB. calculate boxing level, and open that many times

NB. ============================================================================
Lab Section Apply At Level  L:n  S:n
u L: n   is a verb that applies u within the boxed structure of
its operand(s), at boxing level n .

The most common use is   u L: 0 which applies u within the innermost boxes.

The details of  u L: n when n is not 0, or when the compound is used
dyadically, are rather intricate and you should refer to _J for C
Programmers_ if you need the details.


u S: n  applies u at the same places as u L: n, but instead of leaving
the result in the boxed structure, the results of applying u are concatenated
into an array.
)
] a =: ( ('abc' ; 'de') ; 'fghi') ; 'jkl' ; 'mno'  NB. Boxes
$ L:0 a  NB. Get the shape of each innermost box
$ L:1 a  NB. Go through the boxes stopping when you hit a boxing level of 1

$ S:0 a  NB. Assemble shapes into a list

NB. ============================================================================
Lab Section Comparisons on Boxes
A limited set of comparison operation work on boxes.  Boxes can be compared for
equality, but not for greater-than or less-than.

Boxes are equal if the contents of the boxes MATCH.  Two nouns match
if they have the same shape and item values.  Empty operands of the
same shape are considered to match even if they have different types.

When the contents of boxes are compared for equality of values, tolerant
comparison is used.

The verbs for ordering (/: grade up   \: grade down  I. insertion index)
contain implied comparisons that test for greater-than and less-than as well
as equality.  These implied comparisons DO work for boxed values, so you can
sort boxes into order based on their contents.
)
(<3) = (<3)  NB. Two equal boxes
(<3) = 2 ; 3 ; 4  NB. = has rank 0, so there are 3 comparisons
(<1) =    <1.00000000000001  NB. Tolerant comparison
(<1) =!.0 <1.00000000000001  NB. Intolerant comparison
'a' = <3  NB. No domain error, but a character is never equal to a box
(<'a') = <3  NB. Nor do the contents match
(<$0) = <''  NB. The empties have different type, but they match
(<3) < (<4)   NB. Greater-than comparison not allowed
/:~ ;: 'there is a tide in the affairs of men'  NB. OK to sort boxed strings

NB. ============================================================================
Lab Section Fetch  {::
x {:: y   selects item x from y and opens it.

Actually it does a good deal more than that, but we will not
get the full story until we have discussed selection in detail.
)
]a =: ;: 'there is a tide in the affairs of men'
1 {:: a  NB. Open box 1
3 {:: a  NB. Open box 3
NB. More to come...

NB. ============================================================================
Lab Section Similarity to C Structures
A C structure is a single entity that contains a sequence of other
entities.

That is like a list of boxes in J.

An array of C structures is like a higher-rank array of boxes.

A structure of arrays is like a list of boxes where the contents of a box
are an array.

C has nothing analogous to a single box.

x {:: y is analogous to accessing a structure element in C.
)

NB. ============================================================================
Lab Chapter Selected Verbs For Arrays
NB. ============================================================================
Lab Section Monad i. and i:
i. y  creates a numeric noun whose shape is y, and whose atoms are
consecutive integers.  We will use i. y often to create nouns for
demonstrating the topics under discussion.  Monad i. has rank 1, because
the shape can be a vector of any length.

i: y  creates a noun containing integers running from -y to y.  Monad
i: has rank 0.
)
i. 4   NB. A list of 4 integers
i. 3 4   NB. A 3x4 array of integers
i. 2 3 4  NB. A 2x3x4 array of integers
i. 0  NB. An empty array of integers
$ i. 0   NB. It's a list with shape ,0

i: 3
i: _3

NB. ============================================================================
Lab Section Dyad # (Select Items Using a Mask)
x # y uses x as a mask to select items of y.  The rank is 1 _ so that
x is a numeric list, and y can have any rank.  #x must be the same as #y.
Each item of x gives the number of copies to keep of the corresponding
item of y.

The result is a list whose items are items of y; therefore it has the
same rank as y (unless y is scalar), and its items have the same shape
as items of y, but the number of items of the result is usually different from
the number of items of y.

In the most common case, where x is a Boolean list, the result contains just
those items of y for which the item of x is 1.

If x contains values greater than 1, the corresponding items of y are repeated
in the result.

If an item of x is complex, the imaginary part tells how many FILLs to insert
after the itmes of y.  Fills are cells with the shape of items of y, but
whose atoms are 0 (for numeric y), ' ' (for literal y), or a: (for boxed y).
The fill can be changed using the Fit conjunction !., as discussed later.


If x is a scalar it is treated as if it were (#y) # x .
)
1 0 1 # 'abc'  NB. Keep items corresponding to 1, discard corresponding to 0
1 0 2 # 'abc'  NB. Repeat an item
1 0 1 # i. 3 4  NB. ITEMs are selected
0 # i. 3 4  NB.  Scalar x; it's like 0 0 0.  What is the shape of the result?
$ 0 # i. 3 4  NB. It's a list of 0 items of length 4
1j1 0 1 # 'abc'  NB. Insert a fill after item 0
NB. Alas, there's no way to insert a fill before the first item
1j1 0 1 #!.'*' 'abc'   NB. Insert a fill, but use * for the fill

NB. ============================================================================
Lab Section Dyad { (Select Items By Index)
x { y selects parts of y specified by x.  The general form of x { y, where x is
boxed, gives detailed control over the portions of y that are to be selected.
We will cover that later.  Here we will cover the case of unboxed numeric x.

When x is a nonnegative scalar number, x { y selects item number x from y.
The first item is selected by 0 and the last is selected by (#y)-1.
x may not be larger than (#y)-1.

When x is negative, x { y selects item number x+(#y).  For example, _1 selects
item (#y)-1, in other words, the last item.  The last item is selected by _1
and the first one by -#y.  x may not be less than -#y.

The rank of dyad { is 0 _ which means that if x is an array, the result of
x { y is an array of items of y.
)
2 { 'abcdefgh'   NB. Select item 2
2 { i. 3 4   NB. Here item 2 is a list
3 { i. 3 4   NB. If you index past the end, you get an error
2 1 3 { 'abcdefgh'  NB. Select 3 items, run them into a list.
(2 2 $ 3 0 1 5) { 'abcdefgh'  NB. Shape and order of indexes is preserved

NB. ============================================================================
Lab Section |. and |: (Reverse and Transpose)
|. y reverses the order of the items of y.  Pay attention to that word 'items'!
Only the first axis is reversed.

|: y reverses the AXES of y.  For a rank-2 array, this is the matrix-transpose
operation: an mxn matrix becomes an nxm matrix.

x |: y is a generalization of the transpose.  x is a list of axis numbers, and
the axes are reordered, moving the given axes to the end.
)
|. 'abcde'  NB. Reverse order of items, atoms here
|. i. 3 4  NB. Reverse order of items, lists here.  Each list is unchanged

|: i. 2 4  NB. Transpose a 2x4 matrix, giving a 4x2 matrix
|: i. 2 3 4   NB. Transpose of a rank-3 array.  Shape is 4 3 2

0 |: i. 2 3 4  NB. Axis 0 moves to end of axes, so shape is 3 4 2

NB. ============================================================================
Lab Section Dyad |. (Left Rotate and Left Shift)
x |. y has nothing to do with reversing or transposing axes.  It is the
Left Rotate operation, where x tells how many places to rotate y left.

If x is negative, that is a Right Rotate by -x places.

In a Rotate, the values that are pushed off the end of the array are moved
into the vacated positions on the other end.  This differs from a Shift,
in which the values pushed off the end are discarded, and the vacated
positions are filled with a constant.

To perform a Left Shift, you specify the constant to use for the fill, with
the Fit conjunction:  x |.!.0 y is a Left Shift, filling with 0.

The rank of dyad |. is 1 _ which means that x can be a list.  In that
case the atoms of x give the rotate/shift amounts for successive axes.
Axes beyond #x, that is, axes whose rotate/shift count is omitted,
are left unchanged.  In the most common case, where x is a scalar, this
means that the first axis is rotated/shifted, but each item is unaffected.
)
2 |. 'abcdefgh'  NB. Rotate left 2
_2 |. 'abcdefgh'  NB. Rotate right 2
2 |.!.'*' 'abcdefgh'  NB. Shift left 2, fill with *
_2 |.!.'*' 'abcdefgh'  NB. Shift right 2, fill with *

1 |.!.99 i. 3 4  NB. Shift left, first axis only.  Items are unaltered

1 _2 |.!.99 i. 3 4  NB. Shift Axis 0 left 1, axis 1 right 2

NB. ============================================================================
Lab Section {. {: }. }: (Take and Drop)
The suite of verbs {. {: }. }: perform the Take and Drop functions.
Take is selecting sequential items from the beginning or end of an
array; Drop is discarding sequential items from the beginning or end of
an array.

x {. y is Take.  x tells how many items of y to keep.  The result has
|x items, and will have the same rank as y (unless y is scalar).
If x is positive, x items are taken beginning at the first item;
if x is negative, -x items of y are taken ending at the last item.

The rank of dyad {. is 1 _ which means that x can be a list, in which case
successive atoms of x specify the amount to be taken from successive axes
of y.  Axes beyond #x are left unchanged.

The shape of the result always has x as its starting prefix.  If an atom of x
specifies more items than exist for that axis, that is called an OVERTAKE and
the surplus items are created as fill cells: 0, ' ', or a: depending on the
type of y.  The value of the fill cell can be given with the Fit conjunction !.
.
)
3 {. 'abcdefgh'   NB. Take the first 3 items
_3 {. 'abcdefgh'  NB. Take the last 3 items
4 {. 5 6  NB. Overtake: extra position is fill
_4 {. 5 6  NB. Overtake: extra position (at front) is fill
4 {.!.99 (5 6)  NB. Overtake, with fill specified

_2 {. i. 4 5  NB. Take the last 2 items of a 4x5 array.  Items are unchanged
_2 2 {. i. 4 5  NB. Take last 2 items, first 2 atoms of each item

_ 2 {. i. 4 5   NB. Infinite value for an axis means 'take it all'

NB. ============================================================================
Lab Section
x }. y is Drop.  It is like Take, but x gives the number of items
to be discarded from the front (if x is positive) or the end
(if x is negative) of the array.  If Drop is instructed to discard
more items than exist, it will be content with discarding all that exist.

As with Take, the result is a list of items of y, and therefore the rank of
the result is the same as the rank of y (unless y is a scalar).

As with Take, x may be a list specifying the amounts to drop for successive
axes.



The handy monads {. {: }. }: are defined in terms of {. and }.

}. y  is equivalent to 1 }. y   i. e. discard the first item
}: y  is equivalent to _1 }. y   i. e. discard the last item

{. y  is equivalent to 0 { 1 {. y   i. e. just the first item
{: y  is equivalent to 0 { _1 {. y   i. e. just the last item

Note that monad {. and {: produce a result that has rank 1 less than that
of y (unless y is a scalar).  They return just a single item, not a
list with that item as the only element.
)
3 }. 'abcdefgh'   NB. Drop the first 3 items
_3 }. 'abcdefgh'  NB. Drop the last 3 items

{. i. 3 4  NB. Take the first item
$ {. i. 3 4  NB. Note: result has rank 1

}. i. 3 4  NB. Drop the first item

NB. ============================================================================
Lab Section /: and \: (Grade and Sort)
J has a novel way of defining sorting.  Once you get used to it, you will
find it to be very powerful.

/: y produces the ASCENDING GRADING PERMUTATION for y.  This permutation is
defined by saying that (/: y) { y  has items in ascending order.

What that means is that item i of (/: y) contains the index of the item in
y that should end up in position i when y is sorted into order.

So, item 0 (the head) of (/: y) is the index of the smallest item of y.
Item 1 is the index of the next-smallest, and so on, with the last item of
(/: y) being the index of the largest item of y.

Another way to say the same thing is: find the smallest item of y; its
index becomes the first item of /: y.  Then find the next-smallest; its
index becomes item 1 of /: y; and so on.

If y contains repeated items, the sorted order is the one that is stable,
in other words the one that keeps equal items in order.
)
/: 'abcde'   NB. The grading permutation keeps the list as is
/: 'edcba'   NB. The grading permutation reverses the order...
(/: 'edcba') { 'edcba'   NB. ...as you can see.
/: 3 1 4 1 5 9   NB. Item 1 is smallest; then item 3, then 0, etc.
(/: 3 1 4 1 5 9) { 3 1 4 1 5 9  NB. This puts the list in order
]b =: ;: 'bright is the ring of words'  NB. A list of boxes
/: b   NB. Every list can be sorted into a unique order

NB. ============================================================================
Lab Section
Sorting can be defined in terms of the grading permutation.

x /: y  is x sorted into the order given by y.  In other words, y gives the
sort keys for items of x.  Formally, x /: y  is  (/: y) { x .

To sort a list, let the items of the list be their own keys, i. e.  /:~ y .
This is equivalent to y /: y .

To grade or sort in descending order, use \: instead of /: .
)
/:~ 3 1 4 1 5 9   NB. Sort a list into order
\:~ 3 1 4 1 5 9   NB. Sort descending
]names =: 4 2 $ ;: 'Jones James Smith Philip Jones Howard Smith William'
]salaries =: 50000 60000 65000 70000
/:~ names   NB. The names, in order
salaries /: names   NB. The salaries, sorted into order by name

NB. /: /: y (grade twice) gives the ORDINAL NUMBERs of the items of y.
NB. That is 0 for the smallest item, 1 for the next-smallest, etc.
NB. It is a good exercise, and not so easy, to see that this is so.
/: /: 3 1 4 1 5 9

NB. ============================================================================
Lab Section The i. Family i. i: e. ~. ~: (Searching)
J has a family of verbs that perform searches.  The basis of them all is
x i. y which gives, for each piece of y, the index of the first matching item
in x, or #x if no item of x matches.

Note that I said 'piece' of y, not item.  That is because it is x, the
table being searched, that specifies the rank of the pieces of y.  y is
examined in pieces whose rank is the rank of an item of x.  Formally, if
rix is the rank of an item of x, the rix-cells of y are used as the
values to find in x.  The shape of the result is the rix-frame of y.
)
3 1 4 1 5 9 i. 4  NB. Look for 4; find it at item 2
3 1 4 1 5 9 i. 8  NB. Look for 8; don't find it; result is #x
3 1 4 1 5 9 i. 4 1 8  NB. Items of x have rank 0, look up each atom separately
]l =: i. 5 2  NB. A left operand of rank 2
l i. 6 7  NB. Items of x have rank 1, so this is 1 lookup
l i. 6  NB. y does not contain any items of x - error
]r =: 3 2 $ 6 7 2 1 4 5  NB. A right operand of rank 2
l i. r  NB. Each list in y is looked up in x

NB. ============================================================================
Lab Section
The other members of the i. family use i. as their basis.

x i: y  is like x i. y, but it gives the index of the LAST match, not the
first.  It still gives #x as the result if there is no match.

x e. y is  (#x) ~: y i. x   , in other words 1 if x is contained in y, 0 if
not.  Note that in x e. y, y contains the table and each piece of x is tested
for inclusion in y.

~. y is the NUB of y, defined to be the unique items of y, in the order
in which they first appear in y.

~: y is the NUB SIEVE of y: a list, with one atom for each item of y, whose
value is 1 for each item that is different from all earlier items of y.
(~: y) # y gives the same result as ~. y .


The i. family has the most heavily optimized code in the J interpreter and
you should use it whevever possible.
)
3 1 4 1 5 9 i: 1  NB. The last matching index
2 3 4 e. 3 1 4 1 5 9  NB. For each x, is it in y?
~. 3 1 4 1 5 9  NB. Unique elements of y
~: 3 1 4 1 5 9  NB. A mask that designates the unique elements

NB. ============================================================================
Lab Section E. (Match Pattern)
x E. y  looks for parts of y that match x.  The result is a Boolean array
that has the same shape as y; each atom of y is 1 if x matches the subarray of
y for which that atom is a starting corner.
)
'th' E. 'three things hath thy father'  NB. Find places where x matches y
]r =: 4 4 $ 0 1 2 3  3 0 1 2  2 3 0 1  1 2 3 0  NB. An operand
2 3 E. r   NB. x must have the same rank as y
(,:2 3) E. r  NB. Make x rank 2, then find matching places in y
]l =: 0 1,:3 0  NB. The left operand
l E. r   NB. Find places matching this array

NB. ============================================================================
Lab Chapter Modifiers
NB. ============================================================================
Lab Section Introduction
Conjunctions and adverbs are MODIFIERS.

A modifier consumes its operands and produces a new entity.  The
entity can be any part of speech.  Usually it is a verb, as it will
be in the examples we discuss here.

An operand to a modifier can be a verb or a noun.

A conjunction c has two operands, found before and after the conjunction,
as in   u c v  .  u and v are the operands.

An adverb a has one operand, found before the adverb, as in  u a  .

Named entities can be modifiers as well as verbs and nouns.  You must
know the part of speech of the names in a sentence before you can
understand the sentence.
)

NB. ============================================================================
Lab Section What a Conjunction Does Not Do
The description of & gives, for the dyadic case,

  x u&v y   is   (v x) u (v y)

This is a schematic description only!  The interpreter DOES NOT
actually expand the sequence x u&v y   into  (v x) u (v y) .

The interpreter could have been designed that way, with each name replaced
by an equivalent.  There are several reasons that would be bad design:

1.  There might not be a concise equivalent for the function of the
  conjunction.

2.  At the time u&v is encountered, it is not known whether the
  correct form is monadic or dyadic, so both forms must be substituted;
  but this can lead to huge intermediate results.

3.  Conjunctions are not required to have x and y operands.  Substituting
  the description of what the conjunction does to x and y doesn't make
  sense if it doesn't have an x or y.
)
PREPARE
4!:55 'a';'b';'c';'d'
odisp =: 9!:2''
9!:3 (5)
PREPARE
NB. Model for substituting & symbolically
and =: 2 : 0
u @ v  NB. Monadic form
:
(u@[) v (u@])  NB. Dyadic form
)
a and b
a and b and c
a and b and c and d

NB. ============================================================================
Lab Section What a Conjunction Does
  x u&v y   is   (v x) u (v y)

means that u&v produces a verb, and that verb operates according to the
description (v x) u (v y) .  The verb created by execution of a conjunction
is called a DERIVED VERB.

The proper way to think of this is that & is executed when it is
given its u and v operands.  Execution of & produces a derived verb.
Execution of & DOES NOT look at the x and y operands.  x and y
are operands to the derived verb.

To repeat: in    x u&v y   , u&v is executed to produce a derived verb, and
then   x derived-verb y   is executed to produce the result of the expression.
)
PREPARE
9!:3 odisp
PREPARE

NB. ============================================================================
Lab Section
EXECUTION OF A CONJUNCTION PRODUCES A DERIVED ENTITY.

Some ramifications of this fact:

1.  You can assign the derived verb to a name.  When the named verb is
  executed, the conjunction is not executed again - it was executed before
  the verb was assigned.

2.  Any setup calculation done when the conjunction is executed does not
  have to be done again when the verb is executed.

3.  The derived verb may use any algorithm it wants to produce a result
  consistent with its definition.  Many of the fast idioms in J are
  special combinations which are detected when a derived verb is created.
  The derived verb then uses fast code to produce the correct result.
)
3 +&*: 4
addsq =: +&*:  NB. Assign derived verb to name
addsq          NB. Description of the derived verb
3 addsq 4

NB. ts displays the time and space used by a sentence
ts =: 6!:2 , 7!:2@]
array =: i. 1000000  NB. Define a big array
array i. 12345 67890  NB. Look up a couple of items

NB. Now compare the speeds of two different ways of lookup
ts 'array&i. 12345 67890'
lookarray =: array&i.
ts 'lookarray 12345 67890'

NB. Quiz: explain why the second form is so much leaner than the first,
NB. even though they have exactly the same function

NB. ============================================================================
Lab Section Adverbs
Everything that has been said about conjunctions applies to adverbs as well.

The only difference is that an adverb has only one operand, i. e.
it is executed as u a   (no v operand).
)
NB. Answer to quiz in the previous section:

NB. The execution of array&i. creates an index of array for use in
NB. subsequent searches.  In the sentence
NB.   ts 'array&i. 12345 67890'
NB. array&i. is executed to create the derived verb, and the derived verb
NB. is then executed, and the time for both steps is measured.  In
NB.   lookarray =: array&i.
NB.   ts 'lookarray 12345 67890'
NB. the execution of array&i., including the time to build the index,
NB. happens when lookarray is defined.  The execution of the derived verb
NB. is fast.

NB. ============================================================================
Lab Section Incomplete Conjunctions are Adverbs
If you supply just one operand to a conjunction, you get a modifier
that needs one more operand to be executable.  That sounds like an
adverb, and indeed it is an adverb.  You should enclose the
conjunction/operand pair in parentheses if there are other elements
in the sentence.

Supplying one operand to a conjunction to make an adverb is analogous to
supplying one verb operand to a dyadic verb to make a monad, as in
m&v  or u&n .
)
onpiecesusinghead =: ;.1  NB. Define adverb
# onpiecesusinghead  NB. Applied to a verb, creates derived verb
# onpiecesusinghead '*abcd*ab*def*a'

NB. Define a compound adverb, three adverbs in a row
onboxedpiecesusinghead =: (<@) onpiecesusinghead (;@:)
NB. See the derived verb when an operand is given
}. onboxedpiecesusinghead  NB.
NB. Example of use
}. onboxedpiecesusinghead '*abcd*ab*def*a'

NB. Alternative definition
onboxedpiecesusinghead2 =: 1 : ';@:(<@u;.1)'
}. onboxedpiecesusinghead2

NB. ============================================================================
Lab Section Invisible Modifiers: Hooks and Forks
Hooks and forks are just modifiers that don't have a symbol.
They are recognized by syntax.

When a hook or fork is encountered, it is turned into a derived verb.

The HOOK is a sequence of 2 verbs in a row with no noun operand, as in
   (f g)
The FORK is a sequence of 3 verbs in a row with no noun operand, as in
   (f g h)

The verb derived from the hook has the function
   y f g y (monad)             x f g y  (dyad)
The verb derived from the fork has the function
   (f y) g (h y) (monad)       (x f y) g (x h y)  (dyad)

As with visible modifiers, many sequences of f, g, and h are
recognized as special, and handled by a derived verb with special code.
)
NB. Average of an array
(+/ % #) 3 4 5 6
(+/ 3 4 5 6) % (# 3 4 5 6)
NB. Verb to find average of an array
average =: +/ % #
average 3 4 5 6

NB. ============================================================================
Lab Section Multiple Modifiers: Right-to-Left Order
In a sequence of modifiers, such as
  a@b@c
each modifier's left operand stops with a closest noun or verb that
does not have a conjunction to its left.  So, the sequence given above
would be executed as
  (a@b)@c

This order can be changed with parentheses.

Note that this parsing order, which produces left-to-right execution
of the conjunctions, corresponds to right-to-left execution of the
individual verbs when the derived verb is applied to x and y
operands: c then (b then a).
)
2&+ @ +:   3 4  NB. Double, then add 2
+: @ 2&+   3 4  NB. Add 2, then double?  Why not?
NB. It was executed as (+:@2) & +
NB. but +:@2 is meaningless
+: @ (2&+) 3 4  NB. Add 2, then double

NB. ============================================================================
Lab Section The modifier Monad u/ (Insert)
Monad u/ is the modifier / applied to a verb u .  When applied to
a noun y, u/ y looks at y as a list of its items, and applies
the dyad u between the last two items; then applies u again between
the third-last item and the result of the first operation; and so on,
applying u ((#y)-1) times, ending with the first item.  If we
number the items of y as y0, y1, etc., that means that u/y is simply

y0 u y1 u y2 ... u yn

If there is only one item in y, u/ y is just {. y (the result is the
sole item).

If y has no items, u/ y is the IDENTITY ELEMENT for u .

+/ y produces the sum of the items of y.
)
+/ 3 1 4 1 5 9   NB. Sum of the numbers
i. 3 4  NB. A 3x4 array (3 items)
+/ i. 3 4  NB. Sum the items, producing a list of 4 numbers
i. 1 4  NB. An array with 1 item (the item is a 4-element list)
+/ i. 1 4   NB. Result is a 4-element list
$ +/ i. 1 4   NB. Note the result has shape 4, NOT 1 4
+/ 0$0  NB. Sum of 0 elements is the identity element for +

*./ 1 1 1 1 NB. *. is Boolean AND; this is 1 if all items are 1
*./ 1 1 0 1

NB. ============================================================================
Lab Section The modifier Monad u~ (Reflexive) and Dyad u~ (Passive)
Dyad u~ is defined as follows: x u~y  is equivalent to  y u x .

In other words, u~ switches the left and right operands and passes
them to u .

This can be useful to save some parentheses, or in combination with other
modifiers.


Monad u~ is defined as follows: u~ y  is equivalent to  y u y .

In other words, monad u~ duplicates its y operand as x and executes dyad u
with the two identical operands.
)
5 -~ 3  NB. Same as 3 - 5
2 %~ 4 + 6   NB. Same as (4 + 6) % 4  (remember right-to-left!)

*~ 1 2 3 4  NB. Same as 1 2 3 4 * 1 2 3 4
#~ 1 2 3  NB. Same as 1 2 3 # 1 2 3

NB. ============================================================================
Lab Chapter Monads and Dyads
NB. ============================================================================
Lab Section Valence is a Property of Each Individual Use of a Verb
Every verb exists in two versions, the monadic and dyadic valences.

When you use a verb, the monadic or dyadic version will be selected
according to the context of the sentence in which the verb appears.
)
4.5 <. 5.5  NB. Dyad <. means 'lesser of x and y'
4.5 * <. 5.5  NB. Here <. is the monad, meaning 'next-lower integer'

NB. ============================================================================
Lab Section Be Careful of Valence in Hooks and Forks
When you are writing linear sentences, you can see at a glance what the valence
of each verb invocation is.

When you throw hooks and forks into the mix, the valences are not obvious.
A common error is to think that a verb will have one valence when it actually
has the other.

Remember: in any hook (f g), f is applied dyadically, g monadically.

in a fork (f g h), g is always applied dyadically, and f and h are applied
  dyadically if the fork is applied dyadically.

If either the x or the y operand must be applied to two verbs, you cannot
use a hook - you need a fork.
)
NB. We want a verb pref that takes two character strings x and y and returns
NB. The starting characters of y, for as many characters as there are
NB. characters in x.  So, 'abc' pref 'xyzw' should be 'xyz'.
pref =: # {.  NB. # = count of characters, {. = take that many characters
'abc' pref 'xyzw'  NB. What happened?
NB. pref is a hook, so 'abc' (# {.) 'xyzw'  is   'abc' # {. 'xyzw'
NB. which is 'abc' # 'x'   which is a domain error.
pref =: # {. ]   NB. Try again
'abc' pref 'xyzw'  NB. What happened?
NB. pref is a fork, so 'abc' (# {. ]) 'xyzw'  is
NB. ('abc' # 'xyzw') {. ('abc' ] 'xyzw')    which is a domain error on #
NB. The problem is that we want to apply # monadically
pref =: ({.~ #)~  NB. Switch operands, then apply the hook
'abc' pref 'xyzw'   NB. How did that work?
NB. 'abc' ({.~ #)~ 'xyzw'  is
NB. 'xyzw' ({.~ #) 'abc'   is
NB. 'xyzw' {.~ # 'abc'   is
NB. 'xyzw {.~ 3  is
NB. 3 {. 'xyzw'

NB. ============================================================================
Lab Section Using a Monad in a Dyad's Place: @] and @[
In the pref example we needed to apply # to just one operand.  We saw
one solution: using ~ to fiddle with the operand order so as to put
the left operand into the right operand of a hook, where the verb that
operates on it is used monadically.

Code full of ~ is hard to read, and the trick doesn't work for complex verbs.
If you want to apply a verb to just one of the two operands it is given,
the better solution is to use [ and ] to select the operand you need.

x u@] y   is  u x ] y   which is   u y .   In other words, the x operand
has been discarded and u is applied to y alone, even if the overall verb
u@] is given both x and y.

Similarly, x u@[ y  is  u x.
)
pref =: #@[ {. ]
'abc' pref 'xyzw'   NB. # is applied only to 'abc', giving the desired result

NB. ============================================================================
Lab Section Using a Dyad in a Monad's Place: m&v and u&n
You might want to perform a dyadic function in a place where your
verb is invoked as a monad.

In such a case, since the dyadic verb needs two operands and the monadic
context is going to supply only one, the other operand to the dyad must
somehow be specified inside the monad.

You attach the other operand to the dyad with the & conjunction.
m&v y   is  m v y  , in other words m&v is a monad that executed dyadic v
with the operands m (part of the verb m&v) and y, the operand to the monad.

Similarly, u&n y  is  y u n .  So you choose m&v to make m the left operand
of the dyad, or u&n to make n the right operand.

Some examples of when you need a monad to do a dyad's work:

1.  The function you want is only monadic, as in the dual function u&.v  .
  v is a monad, so if you need two operands, you have to use m&v or u&n.

2.  You need to inject an operand into a long verb.  A simple example
  is  (x&u)&.v  .  This is like x u&.v y except that in (x&u)&.v the
  x operand bypasses the verb v.  This is necessary if the verb v is
  inappropriate for x.

3.  Another example: (f g m&h) y .  Here h must be monadic, since
  it is in a monadic fork, so the only way to pass in the operand is with
  m&h .

4.  Another example: x (f g (m&h)@]) y  .  The same verb is turned into
  a monad and then back into a dyad with a different operand.  We want
  (m h y) instead of (x h y), so first we ignore x with @] and then
  supply m with m& .
)
2 3 %&(1&{) 5 6 7  NB. (1 { x) % (1 { y)
(+/ % #)@:(2 3&{)&.:*:  3 1 4 1 5 9  NB. Geometric mean of items 2 and 3
2 ({ - 1&{@]) 3 1 4 1 5 9  NB. Difference between item x and item 1

NB. ============================================================================
Lab Section Alternative to m&v and u&n: Constant in Train
Another way of putting an operand into a verb is with the CONSTANT FORK

  (noun verb verb)

Instead of the usual fork (f g h) where f g h are verbs, in the constant
fork f is a noun and g and h are verbs.  In this cintext, the noun
acts like a verb with no operands: it just produces itself as its
result.

So, the form  x (f g m&h@]) y could be written

  x (f g m h ]) y

because (m h ]), the constant fork, is equivalent to m&h@] .

The choice between m&v and m v ]  is simply a matter of taste.
Note that (verb verb noun) is not a constant fork - it is just two
verbs applied to a noun, producing a noun - so to replace
u&n you need to write   n u~ ]  .
)
2 ({ - 1&{@]) 3 1 4 1 5 9  NB. Version using &
2 ({ - 1 { ]) 3 1 4 1 5 9  NB. Version using constant fork

0.1 (0&>.)@:(1&<.)@:*  _10 _5 0 4 8 12 16   NB. Clamp x*y between 0 and 1
0.1 (0 >. 1 <. *) _10 _5 0 4 8 12 16  NB. Version using constant fork

1 3 5 7 (i.&1)@:= 3 4 5 6   NB. Find index of first equal items
1 3 5 7 (1 i.~ =) 3 4 5 6  NB. Version using constant fork

NB. ============================================================================
Lab Section The Capped Fork
The verb [: is an odd animal.  In its most frequent use it is never
even executed at all: this is the CAPPED FORK

  ([: g h)

This is fundamentally different from the normal fork
[x] (f g h) y  which is  ([x] f y) g ([x] h y).  The capped fork
[x] ([: g h) y    is   g ([x] h y)  .

([: g h) is equivalent to g@:h .

In the capped fork, g is executed as a monad; in the normal fork,
it is a dyad.  The capped fork is special syntax, a new combination
in addition to the hook and normal fork.  Its behavior is NOT explainable
as the result of [:, because [: is never executed.

Whether you use [: g h   or   g@:h   is a matter of taste.
)
pref =: #@[ {. ]   NB. Using @
pref =: ] {.~ [: # [  NB. Using capped fork

NB. ============================================================================
Lab Section Univalent Verbs; the Suicide Verb [:
If the verb [: is actually executed, it results in a domain error.
This is the fastest way to generate an error in a part of a verb you don't
want to be executed.

The most frequent use of [: is in the form  u : [:  or [: : v .
The conjunction u : v creates a verb whose monadic valence is u
and whose dyadic valence is v .  When [: is specified for a valence,
it guarantees that the verb will fail if invoked with that valence.
You can use this to ensure that verbs are not invoked improperly.
)
[: 5    NB. Always a domain error
5 [: 6
3 4 5 6 (1 + i.) 3  NB. One more than the matching index
IndexPlusOne =: 1 + i.
3 4 5 6 IndexPlusOne 3
IndexPlusOne 1 2 3  NB. Oops, we invoked it as a monad
IndexPlusOne =: [: : (1 + i.)   NB. Make the monadic case fail
IndexPlusOne 1 2 3  NB. Now we get an error

NB. ============================================================================
Lab Chapter Rank in Compounds
NB. ============================================================================
Lab Section How Is @ Different From @: ?
The conjunctions @ and @: are almost identical.

[x] u@:v y   is   u [x] v y

[x] u@v y    is   [x] (u@:v)"v y

u@:v has infinite rank, while u@v has the ranks of v.  What is the practical
difference?

Let rv be the rank of v.  In either verb, v operates on cells of rank rv.
But in u@v, the overall verb (u@v) also operates on cells of rank rv.
This means that the rv-cells of the operand are processed independently
by the overall verb.
)
+/@:*:  1 2 3   NB. Sum of squares
(+/@:*:)"0  (1 2 3)  NB. With rank 0, each atom is independent.
+/@*:  1 2 3   NB. +/@*:  is equivalent to   +/@:*:"0

NB. ============================================================================
Lab Section The fndisplay Tool
A J tool called fndisplay lets you see how operations are applied
on cells.  To invoke it, first load it with

  load '~addons/general/misc/fndisplay.ijs'

If the load fails, use jal to install general/misc addon.

  setfnform 'J'

Define verbs you want to use, giving them a rank if it's not infinite:

  defverbs 'list-of-names'    name  or name"n

Define named nouns you plan to use:

  defnouns 'x y'

When you use those verbs and nouns, the result will show how the
operation was performed.
)
load '~addons/general/misc/fndisplay.ijs' NB. jal addon general/misc
setfnform 'J'
defverbs 'Sum Sq"0'
Sum@:Sq 1 2 3
Sum@Sq 1 2 3    NB. Note the 'Sum' is of only a single 'Sq'

NB. ============================================================================
Lab Section Interpretation of u@v
Many J users explain the difference between @ and @: like this:
in u@:v, v executes and passes its entire output to u, while in u@v,
each output cell of v (i. e. the result of processing one cell) is
passed to u.

This interpretation is not accurate, for two reasons:

1. the control of what gets passed to u, v, and u@v is done not inside v,
  but in a part of u@v that is outside of both u and v;

2.  it gives incorrect results when applied to sequences of more than
  two verbs.

The more accurate interpretation is that u@v has rank v, which means
that the overall verb u@v is applied to v-cells of the operands (by which
we mean cells of the rank indicated by the ranks of v). Since u@v is applied
to each v-cell, it follows that u will operate on an output cell of v.
)

NB. ============================================================================
Lab Section Sequences of @ and @:
A sequence of verbs can be concatenated using many different
combinations of @ and @:, and the combinations usually produce
different results.  You need a way to analyze such sequences.

To succeed, pay attention not just to the individual concatented verbs,
but to the sequence of compound verbs.  Each compound verb has a rank that
determines the size of its cells; these cells are then processed by the
verbs in the compound.
)
NB. 5!:6 <'name' will show you the fully-parenthesized representation of
NB. a name.
nm =: +@:-@*@:%
nm
5!:6 <'nm'

NB. ============================================================================
Lab Section Exegetic Examples
We will now follow some examples of compounds.
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 1.    }.@:({.@>) a


NB. The outermost verb is (}.@:({.@>)) which has rank _ because it
NB. uses @: .  So ({.@>) is applied to the entire a.  This has rank
NB. 0 because of @, so > then {. is applied to each cell, giving 1 4 6.
NB. Then }. is applied, leaving 4 6.

}.@:({.@>) a

load '~addons/general/misc/fndisplay.ijs' NB. jal addon general/misc
setfnform 'J'
defverbs 'drop head unbox"0'
NB. The boxing of the items of a is not displayed
drop@:(head@unbox) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 2.    }.@({.@>) a

NB. The outermost verb is (}.@({.@>)) which has rank 0 because it
NB. uses @ and the rank of {.@> is 0 (from >).  So (}.@({.@>)) is applied
NB. to 0-cells of a independently.  On each 0-cell, ({.@>) is applied
NB. first, which opens the cell and then keeps just the first item,
NB. and then }. is applied which deletes that one item, leaving an
NB. empty list.  Each cell produces an empty list, so the result is
NB. an array of shape 3 0, which display as three blank lines.

}.@({.@>) a

load '~addons/general/misc/fndisplay.ijs' NB. jal addon general/misc
setfnform 'J'
defverbs 'drop head unbox"0'
NB. The boxing of the items of a is not displayed
drop@(head@unbox) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 3.    }.@:{.@> a
tv =: }.@:{.@>
5!:6 <'tv'

NB. The outermost verb is (}.@:{.)@> which has rank 0 (from >) because it
NB. uses @ .  So (}.@:{.)@> is applied to 0-cells of a independently.
NB. The processing follows the same path as example 2: on each cell
NB. >, then {., then }., result 0 3$0 .
NB.
NB. Note that replacing the @: by @ would not affect the result.
NB. }.@{. is equivalent to }.@:{. because both compounds have rank _ .

}.@:{.@> a

load '~addons/general/misc/fndisplay.ijs' NB. jal addon general/misc
setfnform 'J'
defverbs 'drop head unbox"0'
NB. The boxing of the items of a is not displayed
drop@:head@unbox a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 4.    }.@({.@:>) a

NB. The outermost verb is }.@({.@:>) which has rank _ (from {.@:>)
NB.  So }.@({.@:>) is applied to the entire a.  ({.@:>) is
NB. applied first.  It has rank 0 and so it too is applied to the
NB. entire a.  First a is opened, producing a 3x3 array; then the
NB. first item of that is taken, leaving 1 2 3 .  }. is applied
NB. to that, leaving the result 2 3 .

}.@({.@:>) a

load '~addons/general/misc/fndisplay.ijs' NB. jal addon general/misc
setfnform 'J'
defverbs 'drop head unbox"0'
NB. The boxing of the items of a is not displayed
drop@(head@:unbox) a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 5.    {.@>@}. a
tv =: {.@>@}.
5!:6 <'tv'

NB. The outermost verb is ({.@>)@}. which has rank _ (from }.)
NB. So ({.@>)@}. is applied to the entire a. }. is applied first,
NB. leaving (4 5 ; 6 7 8).  {.@> is applied to this.  {.@> has
NB. rank 0 (from >), so it is applied to 0-cells of (4 5 ; 6 7 8)
NB. independently.  Each one is opened and then the first item
NB. is taken, leaving the result 4 6 .

{.@>@}. a

NB. ============================================================================
Lab Section
)
]a =: 1 2 3 ; 4 5 ; 6 7 8  NB. The operand we use for the examples

NB. Example 6.    {.@:>@}. a
tv =: {.@:>@}.
5!:6 <'tv'

NB. The outermost verb is ({.@:>)@}. which has rank _ (from }.)
NB. So ({.@>)@}. is applied to the entire a. }. is applied first,
NB. leaving (4 5 ; 6 7 8).  {.@:> is applied to this.  {.@> has
NB. rank _ (from @:), so it is applied to the entire (4 5 ; 6 7 8) .
NB. Opening that list produces the array (2 3 $ 4 5 0  6 7 8), because
NB. the short item is padded with fill.  The first item of that is taken,
NB. leaving 4 5 0.

{.@:>@}. a

NB. ============================================================================
Lab Section Guidelines For Using @
Your rule should be to use @: for function composition unless you
have thought matters through and are sure that @ is what you really
need.

It is almost never right to use @ when v is an arithmetic operation.
Something like +:@- will apply the compound on each atom
independently, which will be much slower than +:@:- which works
on the entire array.

@> is often used to operate on individual box contents.  @:> will
fail if the contents have dissimilar types, and will add fill if they
have dissimilar shapes.
)

NB. ============================================================================
Lab Section Other Conjunction Pairs & &:  &. &.:
The principles used to make sense of @ and @: also apply for other
ways of making compounds.  The conjunction &: is defined by

  [x] u&:v y   is   [v x] u (v y)

and this is used to define & as

  [x] u&v y    is   u&:v"mv   (mv is the monadic rank of v)


Similarly, &.: is defined as

  [x] u&.:v y   is   (u^:_1) [v x] u (v y)

and this is used to define &. as

  [x] u&.v y    is   u&.:v"mv
)
_1 2 _3 4 5 i.&:|   _4 2   NB. Take absolute value, then look for y in x
_1 2 _3 4 5 i.&|   _4 2   NB. Rank 0 makes no sense

+/&.:*: 1 2 3   NB. Square root of sum of squares
+/&.*: 1 2 3   NB. As rank 0, a silly operation

NB. ============================================================================
Lab Chapter Concatenation
NB. ============================================================================
Lab Section Verbs for Concatenation
A number of verbs concatenate two operands.  They are:

,  (append)
,. (stitch)
,: (laminate)
monad ;  (raze)


These verbs are all variations on the same basic function.
)

NB. ============================================================================
Lab Section Raze, the Prototype for Concatenation
Monad ; , the verb called Raze, is the general case of concatenation.
We will examine it and define the other verbs as special cases.

Monad ; applies to boxed operands.  It opens each box and concatenates
the contents, in a way to be defined presently.  Since it is the contents
of the boxes that are concatenated, the actual shape of the boxed operand is
immaterial except to indicate the order in which the contents are
concatenated.

The items of each boxed contents are concatenated into a list whose items are
the same shape as the items of the boxed contents.  So, if (i. 2 3) with
item shape ,3 is concatenated with (i. 5 3) with item shape ,3 , the
result has items of the same shape - ,3 - and so the result shape is
7 3, with 2 items from (i. 2 3) followed by 5 items from (i. 5 3).

If the contents of the boxes have items of different shapes, the situation
gets more complicated.
)
(i. 2 3) ; (i. 5 3)   NB. Two boxes
; (i. 2 3) ; (i. 5 3)   NB. Contents concatenated

NB. ============================================================================
Lab Section Raze Overview
Some observations to help you follow the detailed description of raze:

1.  Smaller items are padded with fill to match the size of the largest item.
  Note: ITEMS of the boxed contents, not the whole boxed contents.  The items
  are brought up to common shape, and then the items of the several contents
  are concatenated into one long list of items.
)
NB. Examples of raze:
]op =: 2 ; 5
;op
]op =: 2 3 ; 5  NB. Items are scalars; no extension
;op
]op =: (i. 3 3) ; i. 2 2   NB. Short item is extended
;op

NB. ============================================================================
Lab Section
2.  Scalars, however, are not padded with fill; their values are replicated
  as required.  Also, they do not affect the size of the items of the result.
  The size of an item of the result is calculated by looking at all the
  contents that are arrays, and then each scalar is replicated to
  produce a single item of that size.
)
]op =: (i. 3 2) ; 9   NB. Scalar is replicated
;op
]op =: (i. 2 3) ; (i. 2 2) ; 6   NB. Scalar is replicated; short list padded
;op

NB. ============================================================================
Lab Section
3.  If the contents have different ranks, the lower-rank arrays are brought up
  to the rank of the largest-rank contents by adding leading axes, of
  length 1, as many times as needed.  So, a contents of shape 3 4 will
  be treated as having shape 1 3 4 if the largest contents has rank 3, or
  1 1 3 4 if the largest contents has rank 4, and so on.  Note that there
  is no replication or padding: the shape is changed, but not the number of
  atoms in the array.

  The extension of rank happens first thing, before the items are padded
  with fill.

  As with padding, scalars do not participate in this extension of rank.
  A scalar always becomes a single result item whose shape is determined
  by the shape of the other elements.
)
NB. Scalar is replicated; short list has axis added, then items are padded with fill
op =: (i. 2 3) ; 8 9 ; 6
;op

]op =: (i. 2 0 4) ; (i. 0 2) ; 6
NB. Watch this carefully: first (i. 0 2) has a leading axis added, to make it
NB. have shape (1 0 2).  The largest item shape is 0 4.  The scalar is
NB. replicated to shape 0 4.  The items are run together, producing shape
NB. 4 0 4, an empty noun.  This will be analyzed in detail later.
;op
$;op  NB. See the shape

NB. ============================================================================
Lab Section
)
NB. See the difference between the scalar 6 and the list ,6.  The
NB. difference comes from the extension of rank of the list ,6.
NB. The ,6 is rank-extended to shape 1 1 1, so items now have shape
NB. 1 4, and the items of (i. 2 0 4) and (i. 0 2) become visible.
NB. This is analyzed in detail later.
]op =: (i. 2 0 4) ; (i. 0 2) ; ,6
;op
$;op

]op =: (i. 2 0 4) ; 8 9 ; 6  NB. 8 9 is padded, scalar 6 is replicated
;op

NB. ============================================================================
Lab Section Raze Details
When the contents of the boxes have different rank, the steps are as follows:

1.  The shape of the result items is calculated.  This is the the maximum,
for each axis independently, of the shapes of the items of the boxed
contents.  For this calculation, any box containing a scalar is ignored,
and among the other boxes, shapes that are shorter than the shape of the
highest-rank contents are extended with 1s to the length of the longest shape.

2.  Each boxed contents is converted to a list of items each of which has
the result item shape.  Any contents that does not have rank higher than
the rank of the result item has its shape extended by adding 1s until it is
a list of 1 item of the correct rank; then the items are padded to the
result item shape.  Items are padded with fills as needed EXCEPT in the
case where the original contents was a scalar: in that case, the scalar is
replicated to the result item shape.

3.  The items of the contents, after having been brought to a common
rank and shape as described above, are concatenated to produce the final
result.

The following sections give a precise model of what ; does.
)

NB. ============================================================================
Lab Section
)
NB. Operation of ; (i. 2 3) ; 8 9 ; 6
]op =: (i. 2 3) ; 8 9 ; 6   NB. The operand
;op  NB. Result of raze
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring scalars
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand scalars by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp

NB. ============================================================================
Lab Section
More examples.
)
NB. Operation of ; (i. 2 0 4) ; (i. 0 2) ; 6
]op =: (i. 2 0 4) ; (i. 0 2) ; 6   NB. The operand
;op  NB. Result of raze
$ ;op  NB. The shape of the empty result
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring scalars
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand scalars by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp
$ > ,&.>/ , cp  NB. The shape of the empty result

NB. ============================================================================
Lab Section
More examples.
)
]op =: (i. 2 0 4) ; (i. 0 2) ; ,6
;op  NB. Result of raze
$ ;op  NB. The shape of the empty result
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring scalars
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand scalars by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp
$ > ,&.>/ , cp  NB. The shape of the empty result

NB. ============================================================================
Lab Section
More examples.
)
NB. Operation of ; (i. 2 0 4) ; (i. 2) ; 6
]op =: (i. 2 0 4) ; (i. 2) ; 6   NB. The operand
;op  NB. Result of raze
]cs =: a: -.~ $&.> op    NB. The shape of each contents, ignoring scalars
]rr =: 1 >. >./ #@> cs  NB. The rank of result (max of individual ranks)
]csp =: (-rr)&({.!.1) &.> cs  NB. The shape of each item, extended with 1
]ris =: }. >./ > csp  NB. The shape of a result item: max of padded shapes
]cp =: ris&$ ^: (0 = #@$) &.> op  NB. Expand scalars by replication
NB. Add leading axes to make each contents a list of items of the correct rank
]cp =: ,:^:(rr - #@$) &.> cp
NB. Pad the items of each contents to the size of a result item
]cp =: (<ris) {."(<:rr) &.> cp
NB. Assemble the items along a single leading axis
> ,&.>/ , cp

NB. ============================================================================
Lab Section Other Verbs For Concatenation; Scalars
The monads ,: ,. and the dyads , ,. ,; perform reshaping and concatenation.

Note that scalars are handled as special cases in most of these.

In dyad , a scalar is replicated to the shape of an item of the other
  operand.

In dyad ,: a scalar is replicated to the shape of the entire other operand.

In monad ,. a scalar is first turned into a one-item list.
)

NB. ============================================================================
Lab Section Dyad , (Append)
x , y  concatenates the x and y operands.  The result is the same as
   ; (<x) , (<y) .

The operation is easier to describe with only 2 operands.

1.  Any scalar operand is replicated to be the shape of an ITEM of the
  other operand.  (This is simpler than the general case of monad ; ,
  because there is no need to look through all the contents to find
  the shape of a result item - with 2 operands the result item will always
  be the shape of an item of the other operand)

2.  If one operand has lower rank than the other, leading axes of length
  1 are added to bring the operands to the same rank.  This does not add
  or remove atoms, it just reshapes the array.

3.  The items of the operands, which now have the same rank, are brought
  up to the same shape by padding with fills at the end of any axis that is
  shorter than in the other operands.

4.  The items, which now have the same shape, are concatenated.
)
(i. 2 3) , 6   NB. Item has shape ,3 so 6 is replicated
(i. 2 0 3) , 6  NB. Item has shape 0 3 so 6 is replicated to that shape...
$ (i. 2 0 3) , 6   NB. ...which gives one more item of shape 0 3, for 3 in all
(i. 1 3) , (i. 3 1)  NB. Result item has shape 3
(i. 2 1 3) , (i. 2 3 1) NB. Result has item shape 3 3, both operands are padded

NB. ============================================================================
Lab Section Appending empty operands
Concatenating operands of dissimilar types produces a domain error.

The exception is if one of the operands is empty.  An empty operand
is filled with fills of the correct kind for the result, so no error
occurs.

Any noun with no atoms is empty.  Another way of saying that is that
any noun with a zero in the shape is empty.

If two empty operands are appended, the type of the result is the
larger of the two operand types.  The order of types is
boolean (low), literal, integer, float, complex , extended, rational (high).
)
0 , ' '  NB. Dissimilar types
0 , ''   NB. Dissimilar types, but OK with one empty
(i. 2 3) , ''  NB. Dissimilar types, result is the nonempty type
(2 3 $ 'abcdef') , 0$0    NB. Dissimilar types, result is the nonempty type
3!:0 (0$0) , ''  NB. Result is numeric
3!:0 (0$1j1) , ''  NB. Result is complex

NB. ============================================================================
Lab Section Monad ,: (Itemize) and Dyad ,: (Laminate)
Monad ,: appends a leading axis of length 1 to the shape  of y.  We
have encountered this operation is our discussions of concatenation.  It
does not change the number of atoms in y.  It is equivalent to [:^:(,0)  .

Dyad ,: adds one leading axis to the operands and then concatenates them.
It is equivalent to (,: x) , (,: y) after a preprocessing step for
scalar operands: if x or y is a scalar it is first replicated to be the
shape of the other operand; additionally, if both operands are scalar,
they are made into one-item lists.  Use dyad ,: when you have
two arrays and you want each one to be an item of a new array, rather
than having their items run sequentially.
)
$ ,: i. 1 2 3   NB. shape extended
,: i. 1 2 3   NB. No atoms added
2 3 ,: 4 5  NB. Creates an array of higher rank
2 3 , 4 5   NB. Keeps the same rank
1 ,: 3 4 5  NB. scalar operand is reshaped

NB. ============================================================================
Lab Section Monad ,. (Enfile Items) and Dyad ,. (Stitch)
,. operates on items of the operand(s).

Monad ,. applies , to each item, converting the item to a list.  The
overall result is a list of the resulting lists, which therefore has rank 2.
If the operand is a scalar, it is given a shape of 1 1 .  So, the result
always has rank 2.

Dyad ,. is equivalent to ,"_1, in other words, items of x and y are
matched up and appended to each other to produce items of the result.
)
i. 2 3 4
,. i. 2 3 4   NB. Convert each 3x4 to a list 4
,. 2 3 4    NB. Convert each atom to a list, producing an array
$ ,. 9  NB. A single atom is also converted to rank 2

(i. 2 3) ,. (i. 2 3)  NB. Run the items together
8 9 ,. i. 2 3  NB. Left items are atoms, right items are list.  Append them

NB. ============================================================================
Lab Section Specifying a Fill Atom
The dyads for concatenation:
  , ,. ,:
all bring their operands (or parts thereof) to a common shape by
padding with fills.

You can use the Fit comjunction to specify what will be used for the fill.

,!.n  ,.!.n  ,:!.n  will use n for the fill.

Replicating a scalar is not fill, and is not affected by Fit.

The fill cannot be changed for monad ; .
)
(i. 2 3) , 3 4  NB. 3 4 is padded to 3 items
(i. 2 3) ,!.99 (3 4)  NB. Use 99 for the fill cell
(i. 2 3) ,!.99 (3)   NB. Scalars are always replicated, not filled

NB. ============================================================================
Lab Section Link (Append Boxed) Dyad ;
x ; y is    (<x) , <^:(0 = L.) y

The operands are concatenated.  The x operand is always boxed, and the
y operand is boxed only if it was unboxed to begin with.

This asymmetrical definition causes an expression like

  x ; y ; z

to box each operand exactly once if they were all unboxed initially.
This is usually what you want.  If z was boxed, and you want to add
a boxing level to it too, you must write

  x ; y ;< z

to force boxing of the last item in the chain.

If you just want to add one level of boxing regardless of the initial
condition, use

  x ,&< y
)
1 ; 2 3 ; 4 5   NB. Create a list of boxes
1 ,&< 2 3 ,&< 4 5   NB. ,&< is not usually what you want
(1 ; 2) ; (3 4 ; 4 5)  NB. Do you expect 2 boxes or 3?
(1 ; 2) ,&< (3 4 ; 4 5)  NB. One way to get 2 boxes
(1 ; 2) ;< (3 4 ; 4 5)  NB. Another way

NB. ============================================================================
Lab Chapter Power/If/Converge/DoWhile
NB. ============================================================================
Lab Section The Power Conjunction ^:
The Power conjunction is easy to define.  u^:n y executes u y n times,
in other words it is    u u u... (n times)... u y  .

x u^:n y  is equivalent to (x&u)^:n y.  This is the same as
x u x u ... (n times)... x u y  .  Note that x stays unchanged during
the repeated execution of u.

u^:n gets interesting when we interpret what it means for special values of n.
)
>:^:2 ] 4 5  NB. Increment, twice
>:^:0 ] 4 5  NB. Increment, 0 times.  Doing anything 0 times leaves y unchanged
2 +^:3 ]4 5  NB. Add 2 three times
(2&+)^:3 ] 4 5  NB. Equivalent form

NB. ============================================================================
Lab Section n=0 (leave y unchanged) and n=1 (execute u)
Executing a verb 0 times is no execution at all.  [x] u^:0 y is the same as
plain y.

[x] u^:1 y  is the same as x u y .

With n 0 or 1, we have the idea of conditional execution:
[x] u^:n y  executes u if n is 1, but it leaves y unchanged if n is 0.

When ^: is used with n guaranteed to be 0 or 1, we think of it as IF .
)
test =: 0
10 +^:test 5  NB. test is false, don't execute +
test =: 1
10 +^:test 5  NB. test is true, execute +

'left' [^:test 'right'  NB. If true, take x operand; if false, keep right
test =: 0
'left' [^:test 'right'

NB. ============================================================================
Lab Section u^:v - Data-Dependent Execution
The right operand of ^: can be a verb.  We write that as u^:v .
u^:v is defined in terms of u^:n.  v is evaluated, and that value is
used as n; u is then executed n times.  In other words,
[x] u^:v y is equivalent to [x] u^:([x] v y) y .

Using u^:v, you can have the execution of u depend on the x and y data.

Two points to note:

  1.  Often the x operand is just used to control the execution, i. e. to
    go into v.  In that case you will be prone to forget that it is also
    an operand to u.  If you want to ignore x, make your u look like u@] .

  2.  You can give u^:v a rank, by writing u^:v"r, to make the number
    of executions of u vary from cell to cell.
)
If =: ^:  NB. Define a mnemonic
5 + If > 4  NB. 'add if greater'
5 + If > 6
1 3 5 (+ If >)"0 ] 2 3 4  NB. Make the test on each atom

1 0 1 0 0 +: If [  5 6 7 8 9  NB. Double if left operand is 1.
NB. What happened?  We applied 1 +: y, not +: y
1 0 1 0 0 +:@] If [  5 6 7 8 9  NB. Apply monad +:
NB. What happened?  We need to apply the verb on atoms of the operand
1 0 1 0 0 +:@] If ["0 (5 6 7 8 9)  NB. That's better

NB. ============================================================================
Lab Section u^:_ (Converge)
[x] u^:_ y means 'apply u an infinite number of times' which could
take a long time.  J stops applying u when the result stops changing.
)
-:^:_ (1)  NB. 1, 1/2, 1/4, 1/8...  limit is 0
NB. Newton's Method.  Define a function and its derivative.
func =: verb : '(3*y^3)+(2*y^2)-10'  NB. a polynomial...
deriv =: verb : '(9*y^2)+4*y'    NB. ...and its derivative
NB. Apply Newton's Method to converge on a solution
newton =: verb : 'y - (func y) % (deriv y)' ^:_
newton 3

NB. ============================================================================
Lab Section u^:v^:_ (DoWhile)
u^:v, when v produces a Boolean, means 'execute u if v is true'.

u^:_ means 'execute u until the result stops changing'.

Put these together in the form   u^:v^:_  and you have
'execute u repeatedly, as long as v is true (and the result changes)'

In other words, you have 'execute u while v is true', which in C syntax is

while(v(y))y = u(y);

u^:v^:_ is an expression rather than a statement, so it can be embedded
in a larger sentence, and it can be given a rank so that different
cells have different numbers of iterations.
)
NB. u is +: (double);  v is <&200  (less than 200); so
NB. +:^:(<&200)^:_ means 'double until the result is not less than 200'.
NB. We want to apply this verb to each scalar independently, so we give
NB. it rank 0:
+: ^: (<&200) ^: _ "0  i. 6
NB. Each number is doubled until it stops changing (0) or gets to 200.

NB. ============================================================================
Lab Section u^:n when n is an array
When n is an array, u^:n is evaluated for each atom of n, and the
results are made into an array using the shape of n as the frame.

The same is true in u^:v if v produces an array.
)
+:^:1 2 3 (2)  NB. Double 1, 2, and 3 times.  Result is a list
+:^:1 2 3 (0 1 2)  NB. Applied to a list, the result is a rank-2 array
+:^:(,0) i. 2 3  NB. +: is not applied, but...
$ +:^:(,0) i. 2 3  NB.  ...the result has an axis added.

NB. ============================================================================
Lab Section u^:(<n)  Save Intermediate Results
When n is boxed, as in u^:<n, it means to execute u^:n but
save all the intermediate results, as if the operation were
u^:(i. n) .

The interesting case is u^:(<_), which executes as u^:_, in other words
execute until the result stops changing.  The result of u^:(<_) is
the list of all the results of repeated evaluation of u .  The last two
items of the result will necessarily be the same.

u^:a: gives the same result as u^:(<_) .
)
NB. Newton's Method, displaying the results of each iteration
func =: verb : '(3*y^3)+(2*y^2)-10'  NB. a polynomial...
deriv =: verb : '(9*y^2)+4*y'    NB. ...and its derivative
NB. Apply Newton's Method, keeping the intermediate results
newton =: verb : 'y - (func y) % (deriv y)' ^:a:
newton 3

NB. ============================================================================
Lab Section u^:n Gerund Forms of Power
Gerund forms of ^: are available, but they are not necessary.

x u^:(f`g`h) y  is  (x f y) u^:(x g y) (x h y)
   same as x (f u^:g h) y

x u^:(g`h) y  is  x u^:(x g y) (x h y)
   same as x ([ u^:g h) y

u^:(g`h) y  is  u^:(g y) (h y)
   same as (u@]^:(g@[) h)
)

NB. ============================================================================
Lab Chapter Inverses
NB. ============================================================================
Lab Section ^:_1 (Inverse)
If u^:1 y means execute y once, and u^:0 y means execute y not at all,
what does u^:_1 y mean?  How can you execute something less than once?

You apply the inverse of u.  The inverse i (called the OBVERSE in most
of J literature) is a function that is undone by u: (u i y) gets you
back to y.

u^:_2 y means apply the inverse twice, and so on.
)
>:^:(_2 _1 0 1 2) 100  NB. Increment _2 etc. times
'a' ,^:(_2 _1 0 1 2) 'wxyz'  NB. Prepend 'a' _2 etc times.
NB. Note that the inverse of adding 'a' is removing one character.

NB. ============================================================================
Lab Section System-Defined Inverses
Many verbs - more than you would expect - have inverses that can be
applied using u^:_1 .  To see if a verb v has an inverse, type

   v b. _1

The result will be the inverse, if any, as a character string.  If there
is no defined inverse you will get a domain error.

Note that the inverse is defined only for the monadic form of a verb.
If you want the 'dyadic inverse', which would be the function i such
that (x u x i y) gets you back to y, you can take the inverse of
x&u .
)
>: b. _1  NB. Inverse of >:
2&* b. _1
, b. _1  NB. No way to invert that!
,&'a' b. _1  NB. But it is possible to invert adding an item to the end
+:@:*: b. _1  NB. The operation is 'square then double'
+/\ b. _1  NB. The operation is 'running sum'.  Clever, eh?

NB. ============================================================================
Lab Section User-Defined Inverses
You can supply the inverse for a verb that lack one: it might be a verb
you wrote, or it might be a verb whose inverse is valid only in a
restricted domain that you happen to know you will be using.

The verb

  u :. v

executes just like u except when its inverse is called for: then, v is
used for the inverse.
)
NB. There is no inverse for -~/\
-~/\ b. _1
NB. We can create one and associate it with -~/\
runningrevdiff =: -~/\  :.  (((+ +/),])/&.|.)
NB. May it take you less time to understand that inverse than it took
NB. me to find it!

NB. We can use it to undo the runningrevdiff verb
runningrevdiff 2 3 4 5 6 7
runningrevdiff^:_1 (2 1 _1 _4 _8 _13)
   runningrevdiff^:(2) 1 1 2 3 5 8 13 21 34
1 _1 _1 _2 _2 _2 _1 1 5
      runningrevdiff^:(_2) 1 _1 _1 _2 _2 _2 _1 1 5
1 1 2 3 5 8 13 21 34

NB. ============================================================================
Lab Section Dual  u&.v  and u&.: v
Why would you go to the trouble of defining f =: u :. v and
then writing f^:_1 when you could just as easily write v?

You wouldn't.

The power of the inverse is in its use in the form u&.:v and u&.v,
which are called DUAL in J.

[x] u&.:v y  is equivalent to    v^:_1 [v x] u (v y)
[x] u&.v y  is the same, but its rank is the monadic rank of v.

u&.:v  applies v to each operand, then performs u, then applies the
inverse of v.

This is a tool of extraordinary economy and expressiveness.  If you have a
verb u that operates in a certain domain, and your operands are in a
different domain, define a verb v that converts to the domain of u; then
u&.:v will transform domains, apply u, and transform back.

Duals will pop up everywhere you look once you have trained yourself to think
of them.
)
<.@(0.5&+) 0 0.4 0.6 0.9  NB. Round to nearest integer
NB. Multiply by 100, round to nearest integer, then divide by 100
<.@(0.5&+) &.: (*&100)  0.001 0.009 0.045 NB. Round to nearest hundredth

NB. The magnitude of a vector is the square root of the sum of the squares:
mag =: +/&.:*:  NB. Square, sum, take square root
mag 3 4 5

NB. The geometric mean is the mean in logarithmic space
mean =: +/ % #
geomean =: mean&.:^.
mean 3 4 5
geomean 3 4 5

NB. Delete first letter of each word.  Add leading space, cut to find
NB. words.  Then, on each word, remove leading space, remove first
NB. character, replace leading space.  Run the words together and then
NB. remove the space added initially
delinitial =: ;@:( <@:(}. &. (' '&,^:_1)) ;.1 ) &. (' '&,)
delinitial 'list of words'
NB. Note the nested uses of dual

NB. ============================================================================
Lab Chapter Gerunds, Tie, and Agenda
NB. ============================================================================
Lab Section What is a Gerund?
A GERUND is a noun that contains a description of one or more entities.
The entities can be any part of speech, but the gerund is a noun.

Every entity has a unique ATOMIC REPRESENTATION (AR) which is a
boxed noun (and therefore an atom, since a box is an atom; hence the name).

A gerund is an AR, or a list of them.

There is no special flag indicating that a noun is an AR.
There are contexts in which you are allowed to use a gerund; if you put
a noun there, you will get an error if the noun does not contain valid ARs.

The simplest way to create the AR of a verb is with the
TIE conjunction ` .
  u`''
will create the AR of u .
)
NB. You can create atomic representation and look at them:
+`''    NB. A verb
(+/ % #)`''   NB. A more complex verb

NB. You can operate on an atomic representation just as on any noun:
> (+/ % #)`''  NB. Remove outer boxing

NB. ============================================================================
Lab Section Atomic Representations
Every entity has an atomic representation (AR), even modifiers.

But since a modifier by itself cannot be an operand to a modifier, the
tie conjunction cannot be used to create the AR of a modifier:
  &`''   for example does not give the AR of & - it is a syntax error.

The foreign 5!:1 will produce the AR of any entity with
a name.  You give the name as a boxed noun, as in

  5!:1 <'name'

The result is the AR.

The foreign 5!:0 is an adverb which, when applied to an AR,
return the entity it describes, which may be any part of speech.

The adverb (`:6) does the same thing.
)
avg =: +/ % #
5!:1 <'avg'  NB. See the AR for a verb
each =: &.>
5!:1 <'each'  NB. See the AR for an adverb
ints =: i. 4
5!:1 <'ints'  NB. See the AR for a noun

NB. ============================================================================
Lab Section
You can make atomic representations by hand, as shown below.

The need for doing so seldom arises.
)
NB. y is string name of verb, result is AR of verb
arverb =: <@,
NB. y is noun, result is AR of noun
arnoun =: <@((,'0')&(,&<))
NB. (adverb) m is modifier (in string form), x (optional) is AR, y is AR
NB. Result is AR of x m y (conjunction) or y m (adverb)
armod =: 1 : '<@((,&<~ ,)&m)@,"0'
NB. y is a list of 3 ARs, result is AR of their fork
arfork =: <@((,'3')&(,&:<))
NB. x is AR, y is AR, result is AR for (x y)
arhook =: <@((,'2')&(,&:<))@,"0

avg2 =: arfork ('/' armod arverb '+') , (arverb '%') , (arverb '#')
avg2 5!:0    NB. Convert the AR back into an entity

avg2 `: 6  NB. Another way to convert to an entity

NB. ============================================================================
Lab Section Making gerunds using ` (tie)
A gerund is an atomic representation (AR), or a list of ARs.

The way to make a gerund out of a list of verbs is with the ` conjunction,
as in

  +`-`(+/ % #)`*

This creates a gerund which has 4 ARs, one for each verb.

This is all you really have to know to use gerunds.
)
+`-`(+/ % #)`*  NB. The gerund is the AR of the component verbs
#   +`-`(+/ % #)`*  NB. The gerund is a list of 4 boxes, one for each verb

NB. Note that, to be hairsplittingly accurate, the form +`'' is not
NB. the AR of the verb + .  That AR is an atom.  The result of +`'' is a
NB. 1-element list:
add =: +
5!:1 <'add'  NB. The AR of the verb 'add'
$ 5!:1 <'add'  NB. it is an atom
$ +`''   NB. +`'' is a list

NB. ============================================================================
Lab Section
If you think about it, you might find it puzzling that a`b`c`d
produces the correct result.  After all, it is executed as
  ((a`b)`c)`d   (because the conjunctions are executed left-to-right)
so why doesn't (a`b)`c produce
  (the AR of the concatenated ARs of a and b) and (the AR of c)
?

The trick is that ` does not blindly produce the AR of its operands.
It produces the AR of a VERB operand, but it leaves any NOUN operand
unchanged.  It then concatenates the two.  So, when ` is applied between
a sequence of verbs, each verb is converted to an AR once and left
unchanged after that.

This explains why our use of +`'' produces the result it did.  '' is an
empty list, so ` converts + to AR form and concatenates that box with
the empty list to produce a 1-item list.  The '' is not converted to AR
form - it just vanishes, an empty list concatenated to a non-empty list.
The concatenation leaves one trace: it is why the result of +`'' is
a 1-item list rather than a scalar.
)
+`-`%`*
NB. Executed as:
((+`-)`%)`*
NB. A noun operand is passed through unchanged:
+`(<'abcd')
NB. You can't concatenate a box to a number, though:
+`1 2 3
NB. You can use ` in place of , to avoid parentheses:
a =: 0 1
b =: 2 3
b`a { 'abcd'  NB. No parens needed, since ` is a conjunction
(b,a) { 'abcd'  NB. Parens required

NB. ============================================================================
Lab Section Using Gerunds: Agenda
The simplest use of a gerund is the form

  gerund @. noun

which is a SELECTED VERB (also known as an AGENDA, for reasons unknown to me)

The gerund is a list of ARs, and the noun is the number of which one should
be used.  The result of the selected verb is a single verb that can then be
applied to operands.

  gerund @. noun   is equivalent to    (noun { gerund) `: 6

  An AR is selected and then turned into a verb.
)
NB. The result of the selection is a verb:
+`-`%`* @. 2
NB. The gerund is any well-formed sequence of ARs:
(+`- , 2 # ^`'') @. 2
NB. The selection follows the usual rules; the selector can be negative,
NB.   in which case the selection count back from the end:
+`-`%`* @. _1
NB. The result of verb selection can be applied like any other verb:
(+`-`%`* @. 2) 1 2 3

NB. ============================================================================
Lab Section Using Gerunds: Computed Agenda
A more useful form of selected verb makes the selection of the verb
depend on the data.  This form is

  [x] gerund @. v  y

where v is a verb that returns a scalar.  The scalar is used to select
the gerund that will be converted to a verb and executed.
The operands of v and the operands of the selected verb are the same:
they are the y and (optional) x operands of the  gerund @. v compound.

v must produce a scalar, but you can use " to make a verb-selection
compound that works on operands of any rank.
)
NB. (>&0 - <&0) y produces signum of y: _1, 0, or 1 depending on sign
(>&0 - <&0)  _3 0 3
1:`*:`+: @. (>&0 - <&0)   _3 0 3   NB. 1 if y=0, y^2 if y>0, y*2 if y<0
NB. It failed because signum was applied to the entire y
NB.  and did not produce a scalar.

NB. A simpler way to take the signum is with the primitive *
*  _3 0 3
1:`*:`+: @. *   _3 0 3   NB. 1 if y=0, y^2 if y>0, y*2 if y<0
NB. It worked!  Why?  The rank 0 n@.v is the rank of v.  The rank of * is 0,
NB. so the selection was performed on each atom individually, and each
NB. application of * produced a scalar.

NB. Note that a different verb was applied to each atom

NB. You can use mnemonics if that helps you remember the operations:
Or =: `
BasedOn =: @.
(1: Or *: Or +:) BasedOn *   _3 0 3

NB. ============================================================================
Lab Section Using Gerunds: Multiple AR Assignment
There is a special form of multiple assignment that interprets the right side
as ARs, converts them to entities, and assigns them to the names in the
left side.

This form is indicated when the first character in the multiple-assignment
target string is ` .  The rest of the string is the names to be assigned,
and the right side is a list of ARs.  More than one name must be assigned.

An example is:

'`plus minus times div' =: +`-`*`%
)
'`plus minus times div' =: +`-`*`%
plus   NB. plus is now a verb
minus  NB. minus too
2 plus 2

NB. ============================================================================
Lab Section Using Gerunds With Structural Modifiers
Many of the adverbs that operate on parts of an array can take gerund
operands in the place of the usual single verb.  The items of the
gerund are converted to verbs, and the verbs are used cyclically: each
time the operand verb is to be applied, one single verb from the gerund
is used, and for the next application of the operand verb, the next verb
from the gerund is applied, and so on, with the verb selection wrapping back
around to the beginning of the gerund if there are more applications of verbs
than there are ARs in the gerund.

The simplest example is

  +`-/ 1 2 3

which is executed as follows:

  u/ 1 2 3    is the same as   1 u 2 u 3

and with the gerund, the verbs are substituted cyclically, so

  +`-/ 1 2 3  is the same as   1 + 2 - 3

All the partitioning and subsequence adverbs support gerund forms.
)
+`-/ 1 2 3
1 + 2 - 3   NB. Equivalent form
+`-/ 1 2 3 4
1 + 2 - 3 + 4  NB. Equivalent form

1 (<:`>:`+:)\  0 1 2 3  NB. Decrement, Increment, Double
NB. One verb was applied to the corresponding subsequence, with the first
NB. verb being repeated because there were more subsequences than verbs.
NB. Note that each subsequence, and therefore each result, is a list, so the
NB. overall result has rank 2.

NB. ============================================================================
Lab Chapter Partitions
NB. ============================================================================
Lab Section Structural Modifiers
While J's ordinary primitives apply to an entire operand, or to every
cell of an operand, J provides ways for you to break up an operand into
pieces and apply a verb on each piece.  Using these mechanisms, you
get the terseness of having short expressions that operate on many
different parts of the operand, combined with the flexibility of having
control over what the parts look like.

The things that make it happen are the STRUCTURAL MODIFIERS: adverbs and
conjunctions that take a verb operand u and create a derived verb, a new verb
that applies u on parts of its y operand.

The verb created by a structural modifier can be invoked as a monad or
as a dyad.  Either case will apply u to parts of y.  In the monadic case,
the parts will be defined by the specification of the structural
modifier, possibly referring to the y operand.  In the dyadic case,
the x operand will be used to define the parts of y that are operated on.

The structural modifiers are the adverbs \ \. and /. and the conjunction ;.  .
;. is a conjunction but its operation varies so much depending on its right
operand that we will consider the right-operand values individually.  The
combination of ;. and a particular right operand is an adverb.
)

NB. ============================================================================
Lab Section Implicit Regular Subarrays: Monad \ and \.
The verbs u\ and u\., when used as monads, apply u on regularly defined
subsets of y.

Each subset is a sequence of sequential items of y.  For u\ the subsets are
all the PREFIXES of y; for u\. the subsets are all the SUFFIXES of y.

A prefix of y is a set of sequential items beginning with the first item.
A suffix of y is a set of sequential items ending with the last item.

u\ y applies u once for each possible prefix, in other words #y times.
The first prefix contains just the first item, and the last prefix contains
all the items.  The result of the applications of u are collected into
an array, with each result of u being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from u.

u\. y also applies u #y times.  The first suffix contains all the items of y,
and the last suffix contains just the last item.
)
<\ 1 2 3 4 5   NB. Box each prefix
<\. 1 2 3 4 5  NB. Box each suffix
#\ 1 2 3 4 5   NB. Length of each prefix
#\. 1 2 3 4 5  NB. Length of each suffix
]\ 1 2 3 4 5   NB. Prefixes: note each is a list, so they make a rank-2 array
NB. The prefixes were padded with fill when they were collected into an array.

NB. ============================================================================
Lab Section Monad u/\ and u/\.
Monad u\ and u\. are most often used when u is of the form u/  .

In monad u/\, u/ is applied to the prefixes.  Consider a 4-item y operand
  y0 y1 y2 y3 .
The first prefix is y0;         applying u/ gives y0
The second prefix is y0 y1;     applying u/ gives y0 u y1
The third prefix is y0 y1 y2;   applying u/ gives y0 u y1 u y2
The last prefix is y0 y1 y2 y3; applying u/ gives y0 u y1 u y2 u y3

Verify that by this definition +/\ gives the running sum, and >./\
gives the largest value encountered before or including each item of y.

u/\. is a mirror-image of u/\ :
The first suffix is y0 y1 y2 y3; applying u/ gives y0 u y1 u y2 u y3
The second suffix is y1 y2 y3;   applying u/ gives y1 u y2 u y3
The third suffix is y2 y3;       applying u/ gives y2 u y3
The last suffix is y3;           applying u/ gives y3

For general u, u/\. is much faster than u/\ because with right-to-left
execution the interpreter can calculate the suffixes in reverse order with just
one application of u for each, while each prefix must be calculated from
scratch.
)
+/\ 1 2 3 4 5  NB. Running sum
+/\. 1 2 3 4 5  NB. Reverse running sum
>./\ 3 1 4 1 5 9 2 6  NB. Running maximum
*./\ 1 1 1 0 0 1 0 1 0 NB. Mask of leading 1s

NB. ============================================================================
Lab Section Explicit Regular Subarrays: Dyad \ and \.
When used as dyads, u\ and u\. apply u on regularly-defined parts of y, but
the parts depend on the x operand.

x u\ y applies u to INFIXES of y: blocks of sequential items of y, not
necessarily starting with the first item or ending with the last.  Which
infixes are used depends on whether x is positive or negative.

If x is positive, u is applied to every possible infix of y that has length x.
The first infix starts with the first item of y, the second starts with the
second item of y, and so on.  If x is greater than #y, there are no
infixes of length x.  The result of the applications of u are collected into
an array, with each result of u being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from u.

If x is negative, u is applied to non-overlapping infixes of length |x, and
if the last such infix ends before the end of y, u is also applied to the
extra remaining bit (the TRAILING SHARD).

x u\. y applies u to OUTFIXES of y: copies of y from which an infix has
been deleted.  The definition follows the definition of x u\ y, but each
application of u is to an outfix instead of the corresponding infix.
)
2 <\ pi =. 3 1 4 1 5 9 2 6 5 3 5  NB. Box each infix
2 (+/ % #)\ pi   NB. Moving average of each 2-infix
3 (+/ % #)\ pi   NB. Moving average of each 3-infix
# pi     NB. There are fewer infixes than items
# 2 (+/ % #)\ pi
# 3 (+/ % #)\ pi
_5 ]\ 'there is a tide in the affairs of men'  NB. non-overlapping infixes
2 <\. 3 1 4 1 5 9   NB. Box each outfix

NB. ============================================================================
Lab Section Explicit Regular Subarrays: Dyad ;.3 and ;._3
Dyad u;.3 and u;._3 are similar to dyad u\, but they can operate on
multidimensional blocks of y.  The x operand describes the blocks.

x is a rank-2 array, in which the first item (0{x) contains the STARTING
MULTIPLE for each block, and the second item (1{x) contains the SHAPE PREFIX
for each block.  The blocks are positioned at each multiple of the starting
multiple that fits in the array, and the size of each block is given by
the shape prefix.  If the shape prefix is shorter than the rank of the array,
the omitted axes are taken in full.

If an item in the shape prefix is negative, the block is reversed along
that axis before u is applied.

The results are assembled in a multidimensional array.

x u;.3 y applies u to every block with a starting point in the array,
even incomplete ones at the boundaries of the array.  x u;._3 y
applies u only to complete blocks.
)
]a =: i. 7 8
(3 3 ,: 2 3) <;.3 a  NB. Spacing 3 3, shape 2 3.  Box the blocks
(3 3 ,: 2 3) <;._3 a NB. Only complete blocks
(3 3 ,: 2 3) (+/ % #)@:, ;._3 a  NB. Average each block (low-pass filter)

NB. ============================================================================
Lab Section Implicit Regular Partitions: Monad /.
u/. y is seldom used.  It applies u to the diagonals of y.

If y is a list, the diagonals are each item individually.  The gerund
form n/. can then be used to apply a different verb to each item.
)
</. i. 3 3  NB. Box the diagonals

NB. ============================================================================
Lab Section Implicit Irregular Subarrays: Monads ;.1 ;.2
u;.1 u;._1 u;.2 and u;._2 apply u on sequences of items of y.  The boundary
points between sequences are called FRETS.  For ;.1 and ;._1, the frets are
at each item that matches the first item of y; for ;.2 and ;._2, the
frets are at each item that matches the last item of y.

For u;.1 and u;._1, the blocks that u is applied to begin at a fret and
run up to just before the next fret (or to the end of the array, after
the last fret).  The result of the applications of u are collected into
an array, with each result of u being one item of the array.  The rank
of the overall result therefore has rank one higher than the rank of
the results from u.

In u;.1, the fret is included in the block.  In u;._1, the fret is not
included in the block, and a block will be empty if there are two frets in
a row.

u;.2 and u;._2 are similar, but the blocks end at the frets rather than
beginning at the frets.  In u;._2 the frets are not included in the blocks.
)
<;.1 ' each word begins with space'  NB. 1st char, space, is the fret item
<;._1 ' each word begins with space'  NB. This time, leave out the fret
<;.2 ' each word ends with space '  NB. Note leading space made a short block
<;._2 ' each word ends with space '  NB. Shorter still with frets removed
]a =. _2 ]\ 0 0 1 2 3 4 0 0 6 7 0 0 7 8 9 10
<;.1 a  NB. Operand can have any rank; here the fret is  0 0
+/;.1 a  NB.  Add up the items in each block

NB. ============================================================================
Lab Section Explicit Irregular Subarrays: Dyads ;.1 ;.2
In the dyadic forms x u;.1 y etc., the boolean vector x indicates the positions
of the frets, rather than having their positions indicated by which items
match the first or last item of y.

u is applied to blocks of y as determined by the frets in x, just as for
the monadic case of ;.1 etc.

Parts of y before the first fret (for ;.1 and ;._1) or after the last fret
(for ;.2 and ;._2) are discarded.  (This situation is impossible in the
monadic uses of ;.1 etc.)

x may be a boxed list, which produces a multidimensional partition
in which the successive boxes of x give the frets for successive axes
of y, and the results of the individual applications of u are assembled
into a multidimensional array.
)
0 0 1 0 1 0 <;.1 'abcdef'  NB. Note leading part of y discarded
]a =. 5 5 $ 'abcdefghijklmnopqrstuvwxy'
(0 1 0 1 0;1 1 1 0 0) <;.1 a  NB. Multidimensional cut

NB. ============================================================================
Lab Section Explicit Irregular Partitions: Dyad /.
In x u/. y, the number of items of x and y must be the same.  The items
of x are KEYS for the items of y, and u is applied to collections of items
of y that have identical keys.

The result of the applications of u are collected into an array, with each
result of u being one item of the array.  The rank of the overall result
therefore has rank one higher than the rank of the results from u.

~. x gives the list of the unique values in x, in the order of their
first appearance in x.  The items of the result of x u/. y are in the
same order as the items of ~.x; that is they are the result of applying
u to collections of y that have the corresponding value of ~.x as key.
)
1 2 1 1 2 2 </. 'prayed'  NB. Keys are 1 and 2
~. 1 2 1 1 2 2
'deddee' </. 'prayed'  NB. Keys can be any shape or type
(~. 'deddee') ;"_1  'deddee' </. 'prayed'  NB. Match keys to collections

NB. ============================================================================
Lab Section Explicit Single Subarray: Dyad ;.0
x u;.0 y applies u to a single subarray of y defined by x.  The x
operand is similar to the x operand of u;.3.  x is a rank-2 array,
in which the first item (0{x) contains the STARTING POINT for the block, and
the second item (1{x) contains the shape of the block. If the shape is shorter
than the rank of the array, the omitted axes are taken in full.

If an item of the starting point is negative, the starting point is relative
to the end of the array (as usual for negative indexing), and the subarray
continues to extend backwards from there.  If an item of the shape is
negative, the corresponding axis is reversed before u is applied.
)
]a =. i. 8 8
(2 3 ,: 3 2) ];.0 a  NB. starting point 2 3, shape 3 2
(2 _3 ,: 3 2) ];.0 a  NB. starting point 2 _3, shape 3 2 (backwards in axis 1)
(2 3 ,: _3 2) ];.0 a  NB. starting point 2 3, shape 3 2 (reversed in axis 0)
(3 ,: 4) ];.0 'abcdefghij'  NB. Works for lists too

NB. ============================================================================
Lab Chapter Remarks On Selected Verbs
NB. ============================================================================
Lab Section Match -: Does Not Mean Identical
x -: y  produces 1 if x and y MATCH, that is, if they are the same in shape
and values.

x -: y is what you use to see if two nouns are the same.  Dyad = has
rank 0, so x = y gives a result for each atom (and fails with length error
if x and y do not agree).  x -: y gives a single result.

Do not think that two values that match are necessairly identical:

1.  The comparison in -: is tolerant.  If you want intolerant comparison
on numerics, use -:!.0 .

2.  Empty operands of the same shape match even if they have different
types.  The consequences of this fact are explored below.
)
1 1 -:       1.000000000000001 1    NB. Tolerant comparison
1 1 -:!.0 ]  1.000000000000001 1  NB. Intolerant comparison

l =: 0$' '  NB. empty literal array
n =: 0$2    NB. empty numeric array
b =: 0$a:   NB. empty boxed array
3!:0 l    NB. The type of the empty is preserved
3!:0 n
3!:0 b
l -: n   NB. The operands are considered to MATCH
l -: b
b -: n
2 {. l   NB. ...but their differences are latent
2 {. n
2 {. b

NB. ============================================================================
Lab Section {.}. |. ;.1 2 _1 _2  can be multidimensional
The dyads that work on arrays:

  {. }. |. u;.1   u;._1   u;.2   u;._2

allow the operation to be performed on multiple axes.  This is a
feature that is often overlooked.

For {. }. |.   x can be a list whose items give the values for successive axes.

For u;.  x can be a boxed list whose opened contents give the frets for
successive axes.
)
]a =: 3 6$'abcdefghijklmnopqrstuvwx'
1 |. a  NB. Rotate a left 1 on axis 0
1 _2 |. a  NB. Rotate a left 1 on axis 0, right 2 on axis 1

2 {. a  NB. Take first 2 items
2 _2 {. a  NB. Take first 3 items of axis 0, last 2 of axis 1

1 0 1  <;.1 a  NB. Box the sequences delimited by frets
(1 0 1  ; 1 0 0 0 1 0) <;.1 a  NB. same, multidimensional

(1 0 1 ; 1 0 0 0 1 0) <@$;.1 a  NB. just box the shapes of the subarrays

NB. ============================================================================
Lab Section Use i.~ to Self-Classify
   i.~ y   which is equivalent to

   y i. y

is is a phrase you might not think would be useful, but it comes up
surprisingly often.  The result is a list whose length is the number
of items of y; for each item, the result gives the index at which
that item first appears in y.

Duplicate items of y all have the same identical result value, so the
result of i.~ y  is to SELF-CLASSIFY y, giving each unique value among
the items of y a number, and then representing each item by its
corresponding number.
)
]a =: ;: 'a rose is a rose is a rose according to Gertrude Stein'
i.~ a  NB. self-classify: an equivalence-class number for each item of a
(i.~ a) { a   NB. see how this restores a
NB. /:@/: gives the ordinal for each number in a:
NB. position of each atom of a in the sorted list /:~ a
/:~ a   NB. a sorted into order
/:@/: a    NB. The ordinals of a
(i.~ a) { /:@/: a  NB. For each a, the ordinal of the first atom with that value
NB. Now: for each item of a, the number of earlier identical items
(i.~   (] - {)   /:@/:) a

NB. ============================================================================
Lab Section %. for Rough-And-Ready Regression
We will use the abbreviation mp for matrix product.  In J, mp =: +/ . *

For a square matrix y,   %. y  is the matrix inverse of y.

If y is not square, it must have more rows than columns, and
     %. y   is   (%. (|:y) mp y) mp (|: y)
   in math notation, %. y is   (YtY)'Yt    where '=inverse, t=transpose


x %. y is matrix division, which is defined as (%. y) mp x .

If x is a vector of observations and y is a matrix of explanatory variables,
x %. y gives the regression coefficients.

y mp x %. y  gives the projection of x onto the column space of y .


%. fails when the columns are dependent.  Regression using %. gives
poor results when the columns are almost dependent - use SVD,
part of the LAPACK addon, in that case.

%. applied to a list treats the list as a column vector, that is, it applies
,. to the list to turn it into an array.
)
mp =: +/ . *
NB. Do some timing on the J sort verb: take stats, perform regression
NB. Setup: verb to time a sentence
etime =: 10&(6!:2)
NB. Vectors of random numbers
irand =: ? 100000 $ 100000
frand =: ? 100000 $ 0
NB. Test 1: integer sort.  cmds is the command string to use, v is vector length
]cmds =: '/:~ irand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
NB. Run em and capture times
t =: > etime&.> cmds
NB. Regression against 4 variables: constant, n, nlogn, and n^2
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. Repeat using floating-point numbers
cmds =: '/:~ frand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
t =: > etime&.> cmds
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. Repeat, restricting numbers to range 0-1000 (meaning lots of repeats)
irand =: ? 100000 $ 1000
cmds =: '/:~ irand {.~ '&,&.> <@":"0 v =: 1 10 100 1000 2000 5000 10000 20000 100000
t =: > etime&.> cmds
t %. (1 ,. ] ,. (* ^.) ,. *:) v

NB. ============================================================================
Lab Section Use +/ . * for Matrix Multiplication
x +/ . * y  is the matrix product of x and y.

You can think of other ways to write this, like +/@(*"1 _)  .

Don't.  +/ . * is heavily optimized in the interpreter.
)

NB. ============================================================================
Lab Section Observations on #. and #:
In  x #. y   x gives the place values of the digits of y, and the result
is the total value.

The weight for each digit is the product of its place value and all
the place values of succeeding digits: in other words,   */\.}.x,1  .

Note that the leading item of x disappears from this list of weights.
It can be anything.  A scalar x is allowed and it is replaicated as much as
necessary.


The reverse of this,  x #: y , uses the same place-value list, but
it converts the single number y into one digit for each item of x.

In this case, the leading item of x is significant.  If the leading
item of the result is not >: 0 and < {. x, the correct multiple of
{. x is added to bring it into that range.

If you want to avoid this modification of the leading item of the result,
make the leading item of x  0 or _ .


When you use #: your x must have as many items as you want places in the
result.  If x is a scalar, you get a scalar result.

If you want a scalar x to be repeated for #: in the same way it was for
#. , use #.^:_1 .
)
10 10 10 #. 9 7 1   NB. Convert place values to a single number
*/\.}.10 10 10 ,1   NB. The list of weights for each place
0 10 10  #. 9 7 1   NB. Leading item of x doesn't matter
10 #. 9 7 1  NB. Scalar x is replicated as needed


10 10 10 #: 971   NB. #: works the other direction
10 10 10 #: 2345  NB. Leading digit is forced into range
0 10 10  #: 2345  NB. That can be prevented...
_ 10 10  #: 2345  NB. ...if leading item is 0 or _

10 #: 2345  NB. A scalar is not replicated for #:
10 #.^:_1 (2345)  NB. But #.^:_1 will do that

NB. ============================================================================
Lab Section Recursion with $:
The $: verb performs recursion.  $: stands for the verb phrase it is
a part of, and so indicates the point or recursion.

$:, like any verb, can be part of many verb phrases at once: in

  a@b@c@d

a is part of itself, a@b, a@b@a, and a@b@c@d .  So which phrase is the
one that is invoked by $: ?

The longest one.  That means the biggest piece of the sentence that you
could put parentheses around, enclosing the $:, and keep the meaning of
the sentence unchanged.

You can also do recursion by name, simply by having a verb invoke itself
either directly or indirectly.
)
factorial =: (* $:@<:) ^: (1&<)  NB. Factorial function
NB.         (                  )  This is the part that $: refers to
factorial 4
factorial 4 5  NB. It might be interesting to see why this happened.  We won't.
     (* $:@<:) ^: (1&<) 4
NB. (                  )  What $: refers to
     1 + (* $:@<:) ^: (1&<) 4
NB.     (                  )  What $: refers to.  More would change the meaning
     (1 + (* $:@<:) ^: (1&<)) 4
NB. (                        )   Now $: refers to the larger phrase

explicitfac =: (* explicitfac@<:) ^: (1&<)
1 + explicitfac 4
(1 + explicitfac) 4  NB. The referent for explicitfac doesn't change

NB. ============================================================================
Lab Section Use # to Repeat Items
x # y  is used with Boolean x to select the items of y for which x is 1.

This is a special case of x .  Generally, an atom of x tells how many
copies of the item of y to take.  This can be 0 or 1 (the Boolean case), or
any other positive integer, which will cause items of y to be repeated in
the result.

Moreover, an item of x can be complex, in which case the imaginary part
tells how many fills to insert after the copies of the item of y; and
the fill atom to be used for all fills can be given by the Fit conjunction
!.f .
)
1 0 1 0 # 'abcd'
1 0 2 0 # 'abcd'  NB. repeated item
1 0j1 2j1 0 # 'abcd'   NB. 1 fill after a couple of the copies
1 0j1 2j1 0 #!.'*' 'abcd'  NB. Use asterisk for the fill

NB. ============================================================================
Lab Section Circle Functions o.
x o. y  applies special function number x to y.  The special functions
are given in the Dictionary and are worth a look.  They include all
the trig functions, plus hyperbolic functions, plus some other functions
including a few related to complex numbers.

You can remember the first few functions by noting that the sine function
is odd, so its number is odd: 1&o. is sine, 2&o. is cosine.

(-x)&o. is generally the inverse to x&o. , so _1 o. y gives the Arcsine of y.
)

NB. ============================================================================
Lab Chapter Selected Foreigns
NB. ============================================================================
Lab Section The Foreign Conjunction !:
FOREIGNS are entities created by the FOREIGN CONJUNCTION !: that do things
outside the language as described by the primitives.  The obvous sorts
of things that are foreign are I/O and interfaces to operating systems
and other software packages.  Other foreigns do things like locale
management, reading and setting interpreter control information,
converting data from one format to another, etc.

All foreigns have the form  m!:n where m and n are numbers.  In effect,
the foreigns are just dozens of numbered entities that have special
functions.  You may want to give the ones you use mnemonic names.

The value of m separates the foreigns into classes, in which the
foreigns m!:n are loosely related.

Sections of this chapter will give a very small sampling of the available
foreigns.
)

NB. ============================================================================
Lab Section Files  1!:n
A file is designated by a boxed filename or a file number which is returned
by 1!:21 .  A filename that is not fully qualified is taken as relative
to the current Working Directory.


1!:1 file   reads file, result is the text of the file

x 1!:2 file   writes (and replaces) file, text is x

x 1!:3 file   appends x to file

1!:0 y  fetches directory information.  y is a string, not a filename, and
        may contain ? and * characters.

1!:11  file ,< index,length   NB. read file, starting at index

x 1!:12 file ,< index  NB. Write file, starting at index (length is #x)

1!:21 file   open file, returning file number

1!:22 filenumber  close file

1!:43 ''  read current Working Directory
1!:44 y  set Working Directory

1!:55 file  erase file
)
1!:43 ''  NB. current Working Directory
1!:0 '*.exe'  NB. executables in the current Working Directory
1!:1 <'version_bin.txt'  NB. Read a file

NB. ============================================================================
Lab Section Types and Conversions  3!:n
3!:0 noun   type of noun: 1=Boolean, 2=literal, 4=integer, 8=float, 16=complex,
            32=boxed, ... (there are more)

x 3!:4 y  x>0: convert J integers to character string (type cast)
          x<0: convert character string to J integers (type cast)
x 3!:5 y   similar, to type-cast J floats

  3!:4 and 3!:5 are used to convert data to a byte string (literal) for
     passing to an external program
)
3!:0 (0)  NB. Boolean
3!:0 i. 3  NB. Integer
3!:0 (0.5) NB. Float

2 (3!:4) 1 2 3  NB. A bunch of nondisplayable characters
a. i. 2 (3!:4) 1 2 3  NB. This shows the characters as numbers

NB. ============================================================================
Lab Section Names  4!:n
4!:0 <'name'  Class of name: _2=invalid _1=unused 0-3=noun, adverb, conj, verb

4!:1 class-list  List of names in class, which is a list:
     0-3=noun, adverb, conj, verb  6=locale
)
a =: i. 2 3  NB. A Noun
plus =: +
4!:0 <'a'
4!:0 <'plus'
4!:1 (0 1 2 3)

NB. ============================================================================
Lab Section Representation  5!:n
5!:5 <'name'  Produces a string which, when interpreted, yields the named
              entity
)
]a =: ('abc';'de';'fgh');0 2.25 4.5 6.75 9 11.25 13.5 15.75
5!:5 <'a'   NB. Clever, eh?

NB. ============================================================================
Lab Section Time  6!:n
6!:0 ''   current time of day  y m d h m s
[x] 6!:2 sentence   execute sentence x times (default=1), report average
                       time
6!:3 y   delay y seconds
)
6!:0 ''
6!:3 (5)

NB. ============================================================================
Lab Section Space  7!:n
7!:2 sentence   execute sentence, report space used
)
7!:2 'i. 1000000'   NB. Create 1000000 4-byte entries
a =: i. 1000000
7!:2 'a'   NB. producing the array as a result doesn't require copying it
7!:2 ']a'   NB. Nor does the ] verb
7!:2 '+a'  NB. But + (conjugate) does, even for a real array

NB. ============================================================================
Lab Section Locales  18!:n
18!:2 y   return search path for locale y
x 18!:2 y  set search path for locale y to x
18!:5 ''  return current locale
)
18!:5 ''  NB. the current locale
18!:2 (18!:5 '')   NB. The path of the current locale

NB. ============================================================================
Lab Chapter Empty Operands
NB. ============================================================================
Lab Section Empty Operands - A Natural Extension
One of the great things about J is that you don't have to count out your
loops carefully.  You apply a verb to an array of cells, and it works
on each cell exactly once.

This is nowhere more important than in the case where there are no cells.
When there are no operand cells, there will be no result cells; but
it is still important for the empty result to have the correct shape.

We must be careful to distinguish between an EMPTY OPERAND, which has
no cells, and an OPERAND WITH EMPTY CELLS, which has cells that are
themselves empty.

Recall some basic terminology.  The RANK r of a verb is the largest
rank the verb can operate on internally; its operand is viewed as
an array of r-CELLs (that is, cells of rank r), and the verb is applied
to each r-cell independently.  The shape of the array of r-cells,
in other words that part of the shape of the operand after the trailing
r axes are removed, is called the r-FRAME of the operand.  The results
of applying the verb on the r-cells are made into an array whose
shape has the r-frame of the operand as a prefix.
)
]a =: i. 2 3 4  NB. Our test operand for the following example

NB. ============================================================================
Lab Section
)
NB. We will illustrate the frame by using a verb that boxes its operand.
NB. Since each box is an atom, the shape of the result will just be the
NB. frame of the original operand.

<"2 a  NB. This is an array of 2 2-cells
$ <"2 a  NB. The 2-frame of a
$ L:0 <"2 a  NB. The shape of each result cell

<"1 a  NB. This is a 2x3 array of 1-cells
$ <"1 a  NB. The 1-frame of a
$ L:0 <"1 a  NB. The shape of each result cell

< a  NB. Rank of < is _; this is a 0-dimensional array of _-cells
$ < a  NB. The _-frame of a  (empty frame)
$ L:0 < a  NB. The shape of each result cell

NB. ============================================================================
Lab Section Definition of an Empty Operand
An empty operand is one that has a zero in its frame.  This means that the
operand has a zero in its shape, but that zero is not one of the last r
items of the shape (r is the rank of the verb)

An operand with empty cells has a zero in one of the last r items of its shape.
Each r-cell has a zero in its shape, i. e. is empty.

It is possible for an operand both to be empty and to have empty cells, if
it has more than one zero in its shape.
)
] a =: i. 2 0 3 4  NB. Our test operand.  No cells.
<"1 a  NB. Box the 1-cells.  Operand is a 2 0 3 array of 1-cells.
$ <"1 a   NB. The 1-frame of the operand.  This is an EMPTY OPERAND

<"2 a  NB. Box the 2-cells.  Operand is a 2 0 array of 2-cells.
$ <"2 a   NB. The 2-frame of the operand.  This is an EMPTY OPERAND

<"3 a  NB. Box the 2-cells.  Operand is a 2 array of 3-cells.
$ <"3 a   NB. The 3-frame of the operand.  This is an OPERAND WITH EMPTY CELLS.
$ L:0 <"3 a   NB. The shape of each operand cell is 0 3 4

NB. ============================================================================
Lab Section Empty Operands Produce Empty Results
Applying a verb to an empty operand produces an empty result.  This
is not a special rule; it follows directly from the standard rules
from processing verbs.

The results from applying the verb to the individual cells are collected
into an array whose shape is the frame of the operand.  Since an empty
operand by definition has a zero in its frame, the result of applying
the verb to that operand will have that zero in the result shape, in other
words it will be an empty result.

But what shape will that empty result have?  Knowing that the result
is empty doesn't tell you its shape, it only tells you that the shape
contains a zero.

For non-empty operands, each application of the verb to a cell gives
a result cell with a definite shape, and the shape of the overall result is
an array of cells with that shape (padding the result cells with fills if
their shapes are not identical).  But with an empty operand, there are
no cells to apply the verb to, so what shape should the result cell have?
)

NB. ============================================================================
Lab Section The Fill Cell
When a verb is applied to an empty operand, the interpreter creates a cell,
called the FILL CELL, which has the shape of one cell of the operand.
The value of each atom in the fill cell is a fill of the appropriate
type: 0 if the operand is numeric, ' ' if the operand is literal,
a: if the operand is boxed.

The verb is applied to this fill cell, and the shape and type of the result
are noted.  The frame of the operand is appended to the shape of the
fill-cell result to give the overall result of the verb.

The beauty of this system is that the empty-operand result fits into the
sequence of result shapes.  2 cells, 1 cell, 0 cells: they form a regular
pattern.
)
v =: monad : '((# y) $ 0 1) # y'"1   NB. Take every other item of list y
v 0 1 2 3 4 5 6
v i. 2 6  NB. Result from 2 cells
v i. 1 6  NB. Result from 1 cell
v i. 0 6  NB. Result from 0 cells.  Fill cell is 6 $ 0
$ v i. 0 6  NB. Note that the shape is correct: 0 items, but each has shape 3
(v i. 0 6) , (v i. 2 6)  NB. Results can be joined properly...
(0 6 $ 0) , (v i. 2 6)  NB. ...which would not be true if empty shape were wrong

NB. ============================================================================
Lab Section When Executing on the Fill Cell Results In Error
If the execution of the verb on the fill cell results in an error,
the interpreter carries on as if the execution had returned a numeric
scalar.

If this is not what you want, you have to program more carefully.
)
5 + ' '   NB. You can't add a literal to a number
5 + ''  NB. Why doesn't this fail?  '' is still a literal.
NB. The verb was executed on a cell of fills, as 5 + ' '.  That failed,
NB. and execution continued as if it had returned 0...
$ 5 + ''  NB. ...so overall result shape is 0

NB. ============================================================================
Lab Section Operands With Empty Cells
An operand with empty cells is processed by the verb just like any
other operand.  No fill cell is created: the verb is applied to the empty
cell and what happens is up to the verb.

The verb may choose to ignore the type of an empty operand.  Most J
primitives ignore the type of empty 'control' operands, treating them all
as numeric, but preserve the type of 'data' operands.  For most
primitives the 'control' operand is the x operand and the 'data' is y.
)
2 |. i. 6  NB. |. rotates y left by the amount x
|. b. 0  NB. Left rank 1, right rank _
' ' |. i. 6  NB. Literal shift amount is not allowed...
'' |. i. 6  NB. but tolerated when empty (treated as numeric)

'' -: 0$0   NB. -: has infinite rank, and treats all empty operands as numeric

{. b. 0  NB. Left rank 1, right rank _
' ' {. i. 8  NB. Literal x not allowed...
'' {. i. 8  NB. ... but tolerated when empty
3 {. ''   NB. y operand is 'data', type is preserved
3 {. 0$a:  NB. empty boxed list
3 {. 0$0  NB. empty numeric list

NB. ============================================================================
Lab Section Handling Empty Operands Yourself
Sometimes executing your verb on a cell of fills will not give you the
correct result.  In those cases, you might need to write code for the
empty-operand case.

By far the most common kind of an empty operand is one that has no
items, in other words when the zero in the frame is the first item in
the shape of the operand.  This is easy to test for using #, and you
can write code like

if. # operand do.
  ...here the operand is known to have items...
end.

More compact ways are shown in the examples.
)
NB. Create a conjunction that applies the verb u if there are items, otherwise
NB. assign the value v
Butifnull =: 2 : 'v"_`u@.(*@#@])'
(>"0) Butifnull ($0)  1 ; 2 ; 3  NB. on nonnull, this just executes (>"0)
$ (>"0) Butifnull ($0)  1 ; 2 ; 3  NB. giving shape 3
$ (>"0) 0$a:   NB.  ...on empty list, shape is 0 0 (because a: contains a list)
$ (>"0) Butifnull ($0) 0$a:   NB. ...so in that case, the default is used

NB. Create an adverb that applies the verb u only if there are items
NB. (otherwise the result is the y operand)
Ifany =: ^:(*@#@])
*/ ''  NB. Result is identity element, which is usually desired
*/ Ifany ''  NB. Result now is unchaged operand, i. e. empty list
$ */ Ifany ''

NB. ============================================================================
Lab Section Interpreter Anomalies
In a few cases the interpreter does not correspond exactly to the
rules laid out here.

By redefining primitives as named verbs you can find the cases where
special code produces unexpected results.
)
NB. One such case was hidden in the previous example:
$ (>"0) 0$a:
NB. Fill cell is a:, which is <0$0; opening that gives 0$0, so an array
NB. of 0 of them has shape 0 0

NB. But wait a minute: > has rank 0, so isn't > the same as >"0 ?
$ > 0$a:  NB. It should be, but it isn't.

$  5 +"1"1 (0 1 $ ' ')
NB. Correct: the fill cell is 1 $ ' '; 5 + 1 $ ' ' is an error, so the
NB. result on the fill cell is taken as 0; an array of 0 of them has shape 0
$  5 +"1 (0 1 $ ' ')  NB. Should be the same, but it isn't
NB. +"1 is handled by special code (integrated rank support)

NB. These are the only anomalous cases I have run across.

NB. ============================================================================
Lab Chapter Selecting From and Modifying an Array
NB. ============================================================================
Lab Section Selection   Dyad {
Early in your J education you learned that x { y selects item x of y.
Now we are going to discuss { in full generality.

To review: x { y gives item x of y.  The left rank of dyad { is 0,
so if x is a list, each atom of x produces an item of the result.
If x is an array, thse items are made into an array.

If x is a scalar, x { y is a single item of y, having the rank of
an item of y, which (except for scalar y) is one less than the rank of y.

If x is a list, the result is a list of items of y, which has the
same rank as y (again, except for scalar y).
)
NB. Our examples will use the alphabet array
] a =: 2 2 4 $ 'abcdefghijklmnopqrstuvwx'

NB. A single item of a has shape 2 4
1 { a
$ 1 { a

NB. A list of the items of a has rank 3, even if there is only 1 item.
NB. This is not special, it's just the normal rules of rank with a verb that
NB. has left rank 0
1 0 { a  NB. Items of result preserve the order of x
$ 1 0 { a
0 1 0 { a
$ 0 1 0 {a
(,1) { a   NB.
$ (,1) { a

NB. ============================================================================
Lab Section Selector in Full Generality
In x { y, x in full generality specifies the selections to be made
along each axis of y.  The set of indexes to be selected along an axis
is called the SELECTOR for that axis.  It can be a scalar or a list.

Since, in general, the selectors for the different axes can have different
number of items (the number of indexes chosen for the axes are independent
of each other), the selectors must be boxed in the general case.  The
selectors then form a list of boxes, with box 0 having the selectors for axis
0, box 1 having the selctors for axis 1, and so on.

Because the left rank of dyad { is 0, the boxed list of selectors must be
boxed again to make an atom that contains all the selection information.

So, in general: x is a scalar box, whose contents are a boxed list, one
box per axis, and the contents of subbox i are the selectors for axis i.
)
NB. A selector to take the first two indexes of each axis, producing a
NB. 2x2x2 array:
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
] sel =: < 0 1 ; 0 1 ; 0 1
sel { a  NB. The selected part of a

NB. ============================================================================
Lab Section
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
NB. The order of the indexes is important, and preserved for each selector:
(< 1 0 ; 0 1 ; 0 1)
(< 1 0 ; 0 1 ; 0 1) { a  NB. first axis reversed
(< 0 1 ; 1 0 ; 0 1) { a  NB. second axis reversed
(< 0 1 ; 0 1 ; 1 0) { a  NB. third axis reversed

NB. The number of indexes can be different for different selectors:
(< 0 1 ; 1 2 ; 0 2 3) { a
$ (< 0 1 ; 1 2 ; 0 2 3) { a

(< 0 1 ; 2 0 1 ; 3 1) { a
$ (< 0 1 ; 2 0 1 ; 3 1) { a

NB. ============================================================================
Lab Section Scalar Selectors Reduce the Rank of the Result
You may have noticed that the shape of the result of x { y is given
by the lengths of the selectors in x.  If box i is a list of shape 2,
for example, the result will have dimension of 2 along axis i.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: <0 1 ; 2 1 0 ; 3 1
; $ L:0 > sel   NB. The shapes of each selector
$ sel { a  NB. match the shape of the selection
sel { a

]sel =: < 1 0 1 ; 2 0 ; 3 2 1
; $ L:0 > sel   NB. The shapes of each selector
$ sel { a  NB. match the shape of the selection
sel { a

NB. ============================================================================
Lab Section
This rule, that the shape of a selector gives the dimension of the
corresponding axis, also applies if the selector is a scalar.

But think about what this means: the shape of a scalar is an empty list.

That means that the corresponding axis disappears from the shape of the result.

When a selector is a scalar, it is saying that the result is not an array
along that axis.  The result is a single slice along that axis, so that
further selection along that axis is impossible.  It is an ex-axis.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ; 0 1 2  NB. The selector
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. First axis has disappeared

sel =: < 0 1 ; 1 ; 0 1 2
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. Second axis has disappeared

sel =: < 1 ; 1 ; 3 1 0
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. First two axes have disappeared

sel =: < 1 ; 1 ; 3
NB. The shapes of selectors, the selection, and its shape.
(; $ L:0 > sel) ; (sel { a) ; ($ sel { a)   NB. All axes have disappeared

NB. ============================================================================
Lab Section
Note that there is a difference between selector that is a scalar,
an empty list, and a list of length 1.

A scalar has shape 0$0 (empty) and the axis disappears.

An empty list has shape ,0 and the result is an axis with 0 dimension.

A list of length 1 has shape ,1 and the result is an axis with dimension 1.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is a scalar, axis disappears
$ sel { a  NB. Axis is gone from shape

]sel =: < (,0) ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is a 1-item list (can't see it in the display)
$ sel { a  NB. ...but it's there in the shape

]sel =: < (0$0) ; 1 2 ; 0 1 2
sel { a  NB. Selector 0 is a 0-item list, selects no items
$ sel { a  NB. ...as indicated by 0 in the shape

NB. ============================================================================
Lab Section Complementary Selection
If a selector (which is the contents of a box which is part of the
contents of the box x) is itself boxed - it is triple-boxed - the
selection is the entire axis EXCEPT the indexes given in the
selector.  Such a selector is called a COMPLEMENTARY SELECTOR.

The axis corresponding to a complementary selector always remains in the
result, even if there is only 1 index selected.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1 2 ;< (<1)  NB. Just one item from axis 0; 0 2 3 from axis 2
NB. NOTE that we had to write ;< for the last axis to get the third level
NB. of boxing.  This is because of the way ; works
sel { a

]sel =: < 1 0 ; (<2) ; 1  NB. like 0 1 ; 0 1 ; 1
sel { a

NB. ============================================================================
Lab Section Simplification: Omitted Trailing Selectors
We have now covered x in full generality.  What remains is to understand
the simple (and more common) special cases.

The first simplification is when there are fewer selectors than axes.
In this case, the selectors that are given refer to the leading axes,
and the leftover axes are taken in full.

In the extreme case, where there are no selectors, all the axes are
left over and the entire array is taken in full.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 ; 1  NB. Axis 2 taken in full, result is a list
sel { a

]sel =: < <1  NB. Axes 1 and 2 taken in full
sel { a

]sel =: < 0$a:  NB. All axes taken in full
sel { a

NB. ============================================================================
Lab Section Simplification: Omitted Non-Trailing Selectors
There is no way to omit a selector except at the end of the axes, but it
is possible to take an axis in full without giving all the indexes.

If you use complementary selection, and select everything EXCEPT nothing,
you will be selecting the axis in full.  The selector to do this is an
empty list (no indexes), boxed (to call for complementary selection).
This is (< 0$0) or equivalently (<'') or (<$0) or, most simply. a: (which
is defined as (<$0) ).  Think of a: as meaning 'all' here.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < a: ; 1 ; 1  NB. Axis 0 taken in full, result is a list
sel { a

]sel =: < 0 ; a: ; 2 0 1  NB. Axis 1 taken in full, result is an array
sel { a

NB. ============================================================================
Lab Section Simplification: Unboxed Scalar Selectors
If all the selectors are scalars, the boxing can be omitted.
x will be a boxed list, one atom per axis.  All the axes given in x
will disappear from the result.

As usual, omitted trailing axes are taken in full.  From this it can be
deduced that the shape of the result is

  (#>x) }. $y
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: < 0 0  NB. Axes 0 and 1 given, axis 2 taken in full, result a list
sel { a

]sel =: < 0 0 2  NB. All axes given, result is a scalar
sel { a

NB. ============================================================================
Lab Section Simplification: A Single Unboxed Scalar Selector
If there is only one selector, and it is a scalar, the boxing of x can
be omitted.  This is the form in which you met x { y.

Remember that dyad { has left rank 0, so when x is a list, it is really
calculating the result for each atom of x independently, and joining those
results into an array.

The interpreter recognizes the case
  list { y
and treats it the same as
  (<<list) { y
so there is no reason to prefer the boxed form.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
]sel =: 1  NB. Select item 1 of axis 0, take others in full
sel { a

NB. ============================================================================
Lab Section Modifying an Array: x m} y
To modify an array you need the array, the values to put into it, and
the places to put them: three operands.  Given J's two-operand-per-verb
limit, this calls for an adverb.

x m} y  installs the values x into y in the places given by m.

The places to be modified are the ones that would have been selected by
m { y.  The values x are replicated, if necessary, to match the shape
of the selected region, and the result has the shape of y.

If x cannot be replicated an integral number of times to match the
shape of the selected region (strictly, if $x is not a suffix of $m{y),
an error results.

If m is an array, the selected region of y is accumulated from the
regions that are selected by the atoms of m.  These regions should not
overlap and should all have the same shape.
)
] a =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
sel =: < 0 ; 0 2 ; 1 2  NB. Select a subregion
sel { a
(2 2 $'ABCD') sel} a  NB. The modified array
('AB') sel} a  NB. Replication of x
('AB') (< 0 ; 0 2 ; 2 1)} a  NB. Atoms match in order

NB. ============================================================================
Lab Section Modifying an Array: Modification In Place
If y is big, x m} y can end up copying all of y to make a tiny change.

If possible, you should use the form

y =: xexpr mexpr} y

The y names must be identical, but xexpr and mexpr can be expressions.
This will modify y with out making a new copy.
)
] b =: 2 3 4 $ 'abcdefghijklmnopqrstuvwx'
b =: ('AB') (< 0 ; 0 2 ; 2 1)} b  NB. Will be performed in place

NB. ============================================================================
Lab Section Modifying an Array: Gerund Form
The form

  x v0`v1`v2} y

is equivalent to

  (x v0 y) (x v1 y)} (x v2 y)

This is not useful for most work, but in tacit verbs it can come in handy.
It does not allow modification in place.
)
('AB';4 2) (0 {:: [)`(1 {:: [)`]} 'abcdefgh'
'AB' 4 2} 'abcdefgh'  NB. Equivalent form

NB. ============================================================================
Lab Section Selecting From A Structure: Fetch  x {:: y
x {:: y allows you to reach into a structure and pull out an item or
a group of items.

x is a list of atoms that will be used successively as the
x operand to x { y.

The first atom x0 is applied, as x0 { y, giving a result y1 (see below).
The next atom is applied, as x1 { y1, giving y2  (see below).
The operation continues until x is exhausted; the final result is the
  last yn  (see below).

After each selection, if the result of the selector was a scalar, the selected
  item is opened, otherwise it is left boxed.

Each selection except possibly the last must select a scalar.
)
] b =: (('abc' ; 'ef') ;< ('ghi' ; 'jkl' ; 'mno') ) ; 'pqr'
0 {:: b  NB. Select item 0 and open it
(0;1) {:: b  NB. Select item 1 of the opened item 0
(0;1;2) {:: b  NB. Select item 2 of the opened item 1
(0;1;2;<<2 0) {:: b  NB. Select from the opened character string
(0;1;2;2 0) {:: b  NB. What went wrong?
NB. The last x was <2 0 which selects 2 from axis 0, 0 from axis 1.
NB. But that is invalid for a list.  Another boxing level is needed so the
NB. 2 0 is interpreted as selectors on axis 0

NB. ============================================================================
Lab Section
More examples.
)
] b =: (('abc' ; 'ef') ;< ('ghi' ; 'jkl' ; 'mno') ) ; 'pqr'
(0;1;<<,2) {:: b  NB. Select item 2 of the opened item 1, but a list this time
NB. Note that the result was not opened, because the selector contained a list
(0;1;,2) {:: b  NB. Why does this open the result?
NB. The selector is <,2 .  This is a list of scalar selectors, one for
NB. each leading axis.  So while the contents of x is a list ,2 , that is
NB. contrued as a list of 1 scalar selector; the selector for axis 0 is
NB. the scalar 2, so it does not specify a list, and the result is opened.
NB. In <<,2, the selector for axis 0 is ,2 , a list, and the result is opened.

(0;(<<,1);2) {:: b  NB. Error - only the last selection can result in a list
0 {:: b   NB. A scalar selector is allowed
1 {:: 'abc'  NB. The y operand does not have to be boxed
0 {:: <5  NB. Fetch from a scalar is not allowed (I don't know why)...
0 { <5  NB. ...but selection with { is OK.  Use > x { y if y might be scalar

NB. ============================================================================
Lab Chapter Fit Conjunction !.
NB. ============================================================================
Lab Section Fit, the All-Purpose Modifier
The fit conjunction !. is applied to a verb to create a modified form.
u!.n, though nominally a modified version of u, is really a new
primitive whose behavior you cannot guess: you have to learn how
Fit modifies each verb it can be applied to.

Fit can be applied only to primitives.

To ease memorization, the new verb u!.n has a function that is
closely related to the function of u.

The meanings of Fit can be put into several classes which we will
cover one by one.
)

NB. ============================================================================
Lab Section Comparison Tolerance
The most frequent use of Fit is to control the COMPARISON TOLERANCE for
comparison operations.

There is a system variable called the default comparison tolerance (DCT),
which is set to 2^_44 when J starts.  The DCT is used whenever a
comparison is made.  When you compare x and y, say with x = y or x < y,
an absolute tolerance is calculated which is (DCT * x >.&| y), in other words,
DCT times whichever of x or y has the larger magnitude.  If the difference
between x and y is no more than the absolute tolerance, the values are
considered to be equal.

So, 1 = 1.00000000000000000001  is true.  Tolerant comparison means that
you don't have to worry much about floating-point inaccuracies' making
comparisons turn out not-equal when you were expecting equal.

Fit specifies the comparison tolerance for a single comparison, replacing
the DCT in that one verb only, as in =!.0 which uses a tolerance of 0, i. e.
intolerant comparison.

Fit sets the comparison tolerance for all the dyadic comparison verbs:
  = ~: < > <: >:   and  -: (match)
Fit is meaningless and harmless if characters are compared.  If boxes
are compared, the contents of the boxes are examined, and the comparison
tolerance is used for comparing numeric contents.

The comparison tolerance can be no more than 2^_34 for reason of efficiency
inside the interpreter.  If your comparisons are sloppier than that, write
your own comparison verb.   [ (|@:- <!.0 t * >.&:|) is a starting point.]

There are verbs to change the DCT, if you should ever need to do that.
)
1 = 1.0000000000000001  NB. Close enough
1 < 1.0000000000000001  NB. Equal, therefore not less-than
0 = 0.0000000000000001  NB. tolerance is relative.  Against zero, always exact
1000000000000000000001 = 1000000000000000000000  NB. Relative tolerance

NB. Use !.0 for exact comparison:
1 =!.0 (1.0000000000000001)
1 <!.0 (1.0000000000000001)

NB. ============================================================================
Lab Section Implied Comparisons
Comparisons are implied in many verbs besides the basic comparison
verbs.  You can use Fit to set the tolerance for these implied comparisons
also.

The i. family of verbs treat one operand as a list and search for
matches within the list.  The verbs in this family are
  Dyads  i. e. u/.   Monads ~. ~:
Fit can be applied to any of these to set the comparison tolerance.

When Fit is 0, as in i.!.0, the i. family uses a completely different
set of algorithms for comparison.  The i.!.0 algorithms are usually
faster than the ones used for i. .

When the operand to be searched is numeric with rank 2 or higher, the !.0
form may be much faster.


NOTE that the sort family, /: \: and dyad I., always use intolerant comparison.


The Signum verb monad * also uses the DCT and accepts tolerance specified by
Fit, but this tolerance is an absolute tolerance rather than a relative
tolerance, because with relative tolerance, comparisons against 0 are
effectively intolerant.


The monad x:, which converts numbers to exact form, finds the simplest
fraction that is tolerantly equal to its operand.  Fit can change
this tolerance.
)
1 2 3 4 5 i. 1.000000000000001  NB. Close enough
1 2 3 4 5 (i.!.0) 1.000000000000001  NB. Not found when exact match required
1 2 1.000000000000001 3 2 </. i. 5  NB. Box matching keys
1 2 1.000000000000001 3 2 </.!.0 i. 5  NB. Require exact matches

0 < 0.000000000000001  NB. Greater than 0 (relative tolerance)
  * 0.000000000000001  NB. But signum is 0 (absolute tolerance)

x: 5%3   NB. Convert fraction to exact form
x:!.0 (5%3)  NB.  Intolerant conversion preserves the floating-point noise

NB. ============================================================================
Lab Section Fills: $!.n  #!.n  #^:_1!.n  {.!.n etc.
Verbs that reshape their right argument include
  Dyad   $ # {. }.   Monad  {. {: }. }:

If the result is bigger than the y operand, the verb has to put
something into the added spaces.  $ repeats its y operand; the
others fill the empty spaces with FILLs which are 0, ' ', or a:
depending on the type of the operand.  For dyad # , fills are indicated
by selection counts that have an imaginary component.

For all of these verbs, Fit can be used to specify an atom that will
be put into each extra space.

Note that Fit must specify an atom, NOT an array.

The inverse of #, #^:_1, expands its y operand to match the 1s in its
x operand.  Fit can be used to control what goes into the added spaces.
)
3 2 $ 'abc'  NB. Fill with spaces
3 2 $!.'*' 'abc'  NB. Fill with *

1 0 0 1j1 0 2 # 'abcdef'  NB. Fill with spaces
1 0 0 1j1 0 2 #!.'*' 'abcdef'  NB. Fill with *

1 0 0 1 0 1 #^:_1 'adf'  NB. fill with spaces
1 0 0 1 0 1&#^:_1!.'*' 'adf'  NB. fill with *.  Note the &, it is required
1 0 0 1 0 1 #^:_1!.'*' 'adf'  NB. Error if used as dyad

5 {. 1 2 3  NB. Overtake, extra spaces are filled with fills (0)
5 {.!.(99) 1 2 3  NB. Fit specifies fill
{.!.99  (0$0)  NB. In the monad, only an empty list can be filled
{.!.'a' (0$0)  NB. Note the type of the empty list can be overridden

NB. ============================================================================
Lab Section Fills In Concatenation Verbs
The verbs that perform concatenation, namely
  dyad ,  ,.  ,:    and    monad ;
have to expand their operands (or parts of their operands) to bring them
to a common shape.  During this operation, fills may be added.  The
value to use for the fill can be specified by Fit.

Note that in these verbs, scalars are always expanded by replication,
not by fill, so Fit does not affect them.
)
(i. 2 3) , (,3)  NB. ,3 must be expanded up to a list of shape 3
(i. 2 3) ,!.99 (,3)  NB. The fill can be specified
(i. 2 3) ,!.99 (3)  NB. A scalar is always replicated, not filled
(i. 1 2 3) ,!.99 (1 2 3 4)  NB. Both operands may require fill

(1 2 3) ,: (,5)   NB. Operands must be brought to common shape
(1 2 3) ,:!.99 (,5)  NB. Fill can be specified
(1 2 3) ,:!.99 (5)  NB. Scalar is replicated, not filled

; (0);(1 2);(i. 1 3)  NB. Items of the highest rank are concatenated
;!.99 (0);(1 2);(i. 1 3)  NB. Fill can be specified, but not for scalar

NB. ============================================================================
Lab Section Shift |.!.n  Including Right Shift 1
x |. y  is the Rotate Left function, which rotates the items of y left
by an amount x.  Items rotated off one end are rotated back in at the
other end.

When Fit is applied, the items that are rotated off one end are discarded,
and the specified fill atom is used instead to fill the items that are
vacated by the shift.


The monadic case |.!.n is an example where the Fit conjunction completely
changes the meaning of its verb.  Monad |. is Reverse, which puts the items
of y into reverse order.  Monad |.!.n has nothing to do with Reverse: it
is Shift Right 1, a variant on dyad |. .  Monad |.!.n shifts y 1 item
to the right, using n as the fill atom for the vacated first position.
It is equivalent to _1&(|.!.n) .
)
2 |. 'abcdef'  NB. Rotate Left 2
_2 |. 'abcdef'  NB. Rotate Left _2, i. e. Rotate Right
2 |.!.'*' 'abcdef'  NB. Shift, shifting in *
_2 |.!.' ' 'abcdef'  NB. Shift Right, shifting in spaces

|.!.99 (1 2 3 4 5)  NB. Shift Right 1, shifting in 99

NB. ============================================================================
Lab Section Mathematical Frills  ^!.n  p. !.n C.!.2
Fit is used with the Power verb ^ to produce a modified power:
  x^!.n y   is   */(x + n*i. y)
With n=0 this is */(y $ x) which is ordinary x^y .

x p.!.n y  is the corresponding variant of p., in that the atoms of x
are coefficients of modified powers of y.

C.!.2 is not at all like C.; instead C.!.2 y produces the parity of
the permutation y: 1 if y is derived from the identity permutation by
an even number of pairwise adjacent interchanges, _1 if by an odd number,
0 if y is not a permutation.
)
5 ^ 3   NB. Normal power
5 * 5 * 5
5 ^!.1 (3)  NB. Modified power
5 * 6 * 7

1 2 1 p. 3  NB. Normal polynomial
+/ 1 2 1 * 3 ^ i.#1 2 1
1 2 1 p.!.1 (3)  NB. Modified polynomial
+/ 1 2 1 * 3 ^!.1 i.#1 2 1

C.!.2 (2 1 0)  NB. 0 1 2->0 2 1->2 0 1->2 1 0, 3 interchanges
C.!.2 (1 2 0)  NB. 0 1 2->1 0 2->1 2 0, 2 interchanges
C.!.2 (0 1 3)  NB. Not a permutation

NB. ============================================================================
Lab Chapter Modular Code
NB. ============================================================================
Lab Section Public and Private Names
Named items in J can be PUBLIC or PRIVATE.

Private names are those that are assigned using =. (not =:) within an explicit
definition.  Such names are visible only within the definition in which
they are assigned.

Public names are those names assigned using =:, or assigned outside an
explicit definition.  They are visible from anywhere.

In the following, note that pubname was visible inside the explicit definition,
but privname, defined privately, is not visible outside:
)
pubname =: 5
expdef =: verb define
privname =. 5
pubname
)
expdef ''
privname

NB. ============================================================================
Lab Section Locales; Current Locale
Each public entity has a SIMPLE NAME; and also exists in a single LOCALE.

The combination of simple name and locale uniquely identifies the entity.

A locale is a namespace.

The simple name and the locale are orthogonal components of the public
name.  The same simple name can exist in multiple locales, and each
simple-name/locale combination refers to a different entity.

The name of a locale is a character string that is a valid J name with
no underscores, like 'fred'.

The name of a locale may contain all numeric characters, in which case it is a
NUMBERED LOCALE and the leading digit must not be '0'.  Numbered locales are
created by the system to represent objects and you are advised not to use
them for any other purpose.

The interpreter keeps an internal variable, the CURRENT LOCALE, which is
the locale used in certain default situations.  The initial value of the
current locale is 'base'; we will learn presently how to change the current
locale.
)

NB. ============================================================================
Lab Section Locatives
The full name of a public entity, specifying both the simple name and
the locale, is called a LOCATIVE.

Locatives come in two forms, DIRECT:

   simplename_localename_

   where the locale name, surrounded by underscores, follows the simple name

and INDIRECT:

   simplename__var

   where the locale name, boxed, is contained in the variable var, which is
   separated from the simple name by two underscores.

Normal non-locative name references refer to names in the current locale.
)
name =: 5
name
name_base_   NB. name was defined in base locale
name_loc1_ =: 6
name_loc1_
name_base_
name_loc2_ =: +
name_loc2_
name_loc1_ name_loc2_ name

NB. ============================================================================
Lab Section Creating, Deleting, and Listing Locales
To create a locale, simply mention it in a locative.  The locale will be
created.

To delete a locale, use

  coerase <'localename'

The locale and all entities in it will be erased.  It is OK to erase a locale
while an entity in it is running; the locale will be erased as soon as no
entity in it is running.

To list the locales in use, use

  conl 0 1   NB. 0 for named, 1 for numbered
)
conl 0 1
coerase  NB. coerase is an alias for 18!:55
coerase <'loc1'
conl 0 1

NB. ============================================================================
Lab Section The Search Path
Every locale contains a SEARCH PATH that is used when a name sought in the
locale cannot be found.

The search path is a list of boxed locale names.  When a name sought in
a locale is not found, the interpreter automatically looks for it next in
the first locale in the search path.  If it is not found there, successive
locales from the search path are searched, in order, until the name is found.

You query and set the search path with
   [value to set] copath locale-name
)
name_a_ =: 5
('a';'z') copath <'b'
name_b_  NB. name not found in b, looked up in a
copath <'b'

NB. ============================================================================
Lab Section The z Locale
Every search path should always end with the locale 'z'.

Any entity put into the z locale will always be visible from a name search
starting in any locale. (If the same name is defined earlier in the search
path, the earlier entity will be found)
)

NB. ============================================================================
Lab Section Name Lookup in Explicit Definitions
When an explicit definition is running, non-locative name references are first
looked for among the private names of the executing definition.  If the name is
not found there, it is searched for starting in the current locale.

Locatives in explicit definitions search the specified locale and its search
path, ignoring the private names of the executing definition.
)

NB. ============================================================================
Lab Section Changing the Current Locale I
You can set the current locale with

  cocurrent locale-name

and query it with

  18!:5 ''

You will often find cocurrent at the beginning of a script, to ensure that
all names defined in the file are defined in the given locale.


Whenever a named entity finishes execution, it resets the current locale to the
value it had on entry to the named entity.
)
name =: 100
name_l2_ =: 'name found in l2'
name
cocurrent <'l2'
name  NB. default lookup now starts in l2
18!:5 ''
cocurrent <'base'
name
18!:5''

NB. ============================================================================
Lab Section Changing the Current Locale II
Executing an entity named by a locative automatically changes the current
locale to the locale given in the locative.  The change occurs as the
first action taken by the named entity, meaning that when the entity completes,
it restores the current locale to whatever it was before the locative was
executed.

The current locale is always changed to the locale named in the locative, even
if the name was found somewhere else in the search path.

The simplest example of this is the form

   name_z_ =: name_xyz_

to define a public entry point.  Then, a sentence like

name 'abc'

executes as follows: 'name' is found in z locale; it is executed (in
the current locale) as name_xyz_; that changes the current locale to xyz
and then executes 'name' in xyz locale.

The result is that users just invoke 'name' without having to worry
about what locale it is in, and name runs with access to the variables
in the xyz locale.
)
PREPARE
4!:55 <'count'
PREPARE
cocurrent <'xyz'
count =: 0
func =: 3 : 0
count =: >: count
y + count
)
func_z_ =: func_xyz_
cocurrent <'base'
func 0
func 0
func 0
count_xyz_  NB. func ran in xyz; all names defined there
count   NB. not in base

NB. ============================================================================
Lab Section Base Classes
A BASE CLASS is a set of programs with associated private data.  The class
defines methods, which are programs that can access the data.

In J, a base class corresponds to a locale.  There is no way to have truly
private data in a locale, but as long as no program uses locatives to
access the names in the locale, only the base class will touch them.

To define a base class, just put

  cocurrent locale-name

at the top of each script file in the class.  All names defined in the script
will then be in the given locale.

The methods can be referred to by locative:

  method-name_locale-name_

or by simple name, if you include the line

  method-name_z_ =: method-name_locale-name_

in the class.  NOTE that adding

  method-name_z_ =: method-name

will not do, because method_name will then be defined as method_name, and
there will be an infinite loop (stack error) when you try to look up the name.
)
cocurrent 'inc'    NB. locale specifier
value =: 0         NB. initialization
add =: 3 : 0       NB. methods
value =: value + y
)
add_z_ =: add_inc_ NB. public interface

cocurrent 'base'
add 3
add 4

NB. ============================================================================
Lab Section Derived Classes
A DERIVED CLASS extends the function of a base class.  It has its own locale,
but also has access to the locale of the base class.

In J, a derived class looks much like a base class.  The extra bit is
that the search path of its base class (i. e. the class the derived class is
extending) is put into the search path of the derived class, so that any
names not found in the derived class will be picked up from the base class.

To insert the base class(es) into the search path of the derived path, include

  coinsert base-class-name(s)

just after setting the locale of the derived class.
)
cocurrent 'inc1'
coinsert 'inc'
add1 =: add @ 1:
add1_z_ =: add1_inc1_

cocurrent 'base'
add1''

NB. ============================================================================
Lab Section Objects in J
An OBJECT is a dynamically created derived class.  The object has its
own individual data-storage area, and shares access to its PARENT CLASS,
which contains programs and any data that is shared by multiple objects.

In J, an object uses two locales: one that is unique to the object, and
one that contains the parent class.  The parent class's locale is put into
the search path of each object derived from the parent.  Methods for the
object are called from the object's locale; the method will be found in the
parent class's locale but will execute in the object's locale.

Entities unique to the object are stored in the object's locale.  Entities,
including code, shared by all objects in the class are stored in the parent
class's locale.

Object locales are created whenever the program wants a new object.  Many
objects sharing the same parent may simultaneously exist.  They are
independent, each isolated in its own locale.  Each has access to
the resources of the parent class.

The parent locale, like the locale for any derived or base class, is created
once, when the script populating the locale is loaded.
)

NB. ============================================================================
Lab Section Each Object Has a Parent Class
The parent class looks like any base or derived class.  In addition it
must define two methods, named create and destroy.

The create verb must perform any initialization needed for the object.

The destroy verb must release any resources that were acquired by the
object, and then call codestroy.
)
NB. Container class.  Numbers can be added and removed.
cocurrent 'container'
create =: verb define
value =: 0$0
)
destroy =: verb define
codestroy''
)

NB. Add number to container, return all values
add =: verb define
value =: value , y
)
NB. Remove number from container, return all values
remove =: verb define
value =: value -. y
)

NB. ============================================================================
Lab Section Creating an Object
With the parent class properly defined, you can create an object whenever
you want one.  There are three steps: (1) create a locale that the object's
entities will be stored in; (2) put the parent class into the path of the
newly-created object locale; (3) call the object's create method to perform
any initialization needed by the object.

The J code to perform these steps is:

objname =: conew unboxed-locale-name-of-base-class
create__objname initialization-parameters

    or the equivalent and preferred shorter form

objname =: initialization-parameters   conew   base-locale-name


The object is a numbered locale, with a system-assigned unique number.
The boxed string containing the locale name is the result of conew.  You
will assign that result to a name (objname above) and then whenever you
want to call a method for the object you will use

  method-name__objname
)
cocurrent 'base'
cont1 =: '' conew 'container'  NB. Needs unused x to be dyad
cont2 =: '' conew 'container'
add__cont1   2 3
remove__cont1 2
add__cont2  i. 4

value__cont2  NB. OK to look at a value directly

NB. ============================================================================
Lab Section Destroying an Object
To destroy an object, call its destroy method.
)
destroy__cont2 ''
value__cont2  NB. The locale no longer exists

NB. ============================================================================
Lab Section Derived Object Classes
An object can be created from a derived class.  As far as accessing methods
goes, this is the same as when any class is derived from another class.  The
difference shows up in the initialization and destruction of the object, at
which times the code for each class in the path must be invoked.

The way to do that is to have each derived class call the create method of
its parent as the first statement in its own create method, and call the
destroy method of its parent as the last statement of its own destroy
method. That way an object will be created from the top of its chain of
class derivation down, and destroyed from the bottom up.

The create method for an object in a class derived from class xyz must start
with

create_xyz_ f. y

and the destroy method must end with

destroy_xyz_ f. y


The purpose of the f. is to prevent the current locale from being switched
to xyz when the parent's method is called.  All code is run in the locale of
the object.

The f. trick is needed only when the parent's method has the same
name (create/destroy) as the derived class's method, and therefore
has to be called using a locative.  You may call parent
methods that have unique names just by invoking the method as usual,
without the locative.
)

NB. ============================================================================
Lab Chapter Performance
NB. ============================================================================
Lab Section What is J Doing In There?
The sections of this chapter will consider factors that affect the performance
of J programs.  These are:

1.  Interpretive overhead - time spent parsing and executing sentences

2.  Execution overhead - time spent executing verbs

3.  Boxing - how boxing affects storage and execution
)

NB. ============================================================================
Lab Section Interpretive Overhead
J scans each explicit definition, breaking it into words, once when the
entity is defined.

However, J parses each sentence every time it is executed.  It really has no
choice, since the meanings of the names, and even what part of speech they are,
may change from one execution of a sentence to the next.

The parsing is quite fast, and you normally don't have to worry about it.
The one exception is when you have a short verb of low rank that it executed on
a large operand.  Then the repeated parsing may become significant.

The solution is to give your verbs the highest possible rank.

It is usually NOT important to write tacit code to get good performance, unless
you are stuck with a function that has to operate on scalars.
)

NB. ============================================================================
Lab Section Execution Overhead
Every J verb has within it the ability to work on operands of different
types, and on arrays of any size.  Every verb except the small number of
forms that execute in-place must allocate an output area to hold the result.

When J verbs operate on large arrays, the execution overhead is negligible.
When J verbs operate on scalars, the overhead is a couple of orders of
magnitude larger than the computation time and dominates the overall time.

The way to keep you verbs fast is to ensure that they work on arrays that are
as large as possible.
)

NB. ============================================================================
Lab Section Measuring Performance With the ts Verb
J gives you a way to see how much time and space your sentences require.
Define

ts =: 6!:2 , 7!:2@]  NB. Return time and space

When you execute a sentence with

ts 'sentence'

the result will be the time it took to run the sentence, and the space used.
For fast sentences, it will be necessary to execute the sentence several times
to get a good average time.  Do that with

repetition-count  ts  'sentence'
)
ts =: 6!:2 , 7!:2@]
a1e6 =: i. 1000000
ts 'a1e6 + a1e6'  NB. Time and space to add 1000000 numbers
ts 'a1e6 +"0 a1e6'  NB. Same with rank 0
plus =: +
ts 'a1e6 plus a1e6'  NB. Same, using a named verb
ts 'a1e6 plus"0 a1e6'  NB. Same, named verb, rank 0

NB. ============================================================================
Lab Section Integrated Rank Support
+, +"0, and plus were fast.  plus"0 was slow.

1.  If plus is defined as +, why the difference?
2.  Why was plus"0 so slow?
3.  Why wasn't +"0 also slow?

Verbs are referenced by name.  The value of plus is not substituted for it
during parsing; rather, plus starts execution, THEN it is executed according
to its value + .

This explains why plus"0 is slow.  The verb that is executed is (plus"0), that
is, an anonymous verb that applies plus to each 0-cell.  For each 0-cell,
the name 'plus' is looked up at executed.  That's a million lookups and
verb-starts, which takes a long time.

But then, why isn't +"0 slow?  And for that matter, why isn't + slow, since it
is a rank-0 verb?  The answer is INTEGRATED RANK SUPPORT.  The primitives
have the internal mechanisms to handle operands of any rank.  And, the
derived verbs created when you assign a rank to a primitive, as with
 +"0, +"1 2, etc., handle the looping internally with a single verb-start.

Integrated Rank Support means you don't have to worry about the rank of
primitives.  You still have to keep the rank of named verbs as high as
possible.
)

NB. ============================================================================
Lab Section Case Study
Here is a verb to take the geometric mean of the absolute value of its
arguments:

geo =: 4 : '%: (*: x) + (*: y)'
geoabs =: geo&|

What should be done to make this verb faster?
)
geo =: 4 : '%: (*: x) + (*: y)'
geoabs =: geo&|
NB. Create some arguments
xx =: 5 - ? 100000 $ 10
yy =: 5 - ? 100000 $ 10
ts 'xx geoabs yy'
geo1 =: +&.*:   NB. Use dual
geoabs1 =: geo1&|
ts 'xx geoabs1 yy'  NB. Using dual version of geo
geoabs2 =: geo&:|
ts 'xx geoabs2 yy'  NB. Using infinite rank
geoabs3 =: geo1&:|
ts 'xx geoabs3 yy'  NB. Using infinite rank and dual
geo2 =: +&.:*:   NB. Use infinite-rank dual
geoabs4 =: geo2&:|
ts 'xx geoabs4 yy'  NB. Using infinite rank and dual

NB. ============================================================================
Lab Section
After you have tried to understand the results of the different versions of
geoabs, follow the explanation below.
   geo =: 4 : '%: (*: x) + (*: y)'
   geoabs =: geo&|
   ts 'xx geoabs yy'
1.30709 1.05146e6
Because | has rank 0, geo&| has rank 0.  That measn that geo&| is applied to
every pair of scalars.  For each pair, the magnitude verb | is run on each
operand, then the sentence defining geo must be parsed, and then it is
executed, with the square verb *: run on each operand, then the + verb, then
square-root.

   geo1 =: +&.*:   NB. Use dual
   geoabs1 =: geo1&|
   ts 'xx geoabs1 yy'  NB. Using dual version of geo
0.481445 1.05037e6
By defining geo using dual rather than an explicit definition, we avoid having
to parse the sentence for each pair of scalars.  geo1 is parsed when it is
defined.  But the overall verb is still rank 0, so each operation is executed
on a scalar.

   geoabs2 =: geo&:|
   ts 'xx geoabs2 yy'  NB. Using infinite rank
0.00682961 3.67232e6
The big improvement comes by replacing geo&| with geo&:| .  These verbs have
the same function, but geo&:| has infinite rank.  The each verb is applied
only once, to the entire operand, and the sentence is parsed only once.

   geoabs3 =: geo1&:|
   ts 'xx geoabs3 yy'  NB. Using infinite rank and dual
0.154895 2.09882e6
When we use geo1&:| instead of geo&:|, performance goes way down.  Why?
Because geo1, defined as +&.*:, has the rank of *:, namely 0.  So the
+. *:, and %: verbs are applied to scalars.  This points up the fact that
using verbs of high rank, not tacit verbs, is what speeds up your programs.
geo1 is tacit but slow.

   geo2 =: +&.:*:   NB. Use infinite-rank dual
   geoabs4 =: geo2&:|
   ts 'xx geoabs4 yy'  NB. Using infinite rank and dual
0.00642561 2.62272e6
Using &.: rather than &., we can create a version of geo1 that uses the dual
but has infinite rank.  This is the fastest of all, but not meaningfully faster
than geoabs2.
)

NB. ============================================================================
Lab Section Boxed Operands
Each noun in J is stored in two parts, HEADER and DATA.  The header contains
the shape and type of the array, and a use count indicating how many references
to the data are active.  The data contains the values in the array, packed
into linear order.

The header and data are stored in different memory allocations.

In a boxed array, the data consists of an array of headers, where each
header points to the data for the contents of the array.  The boxing therefore
corresponds to a level of indirection between the header and the data.

This structure has implications on space and time when you you use boxed arrays:

  If the contents of a box are small, the header may add a substantial amount
  to the space used by the array;

  Executing a verb on the contents of boxes requires opening each box in
  turn, which usually requires a verb-start per box.

The upshot is that you should avoid boxed arrays where the contents of the
boxes are small.

You can see how much space a named entity is using by executing

   7!:5 <'name'
)
xx =: 5 - ? 100000 $ 10  NB. An array of 100000 floats
7!:5 <'xx'
xxb =: <xx   NB. Boxing the whole array doesn't add much
7!:5 <'xxb'
xxbb =: <"0 xx  NB. But boxing each individual float adds a lot
7!:5 <'xxbb'

NB. ============================================================================
Lab Section Use &.> (aka each) Wherever Possible
The special form u &.> applies u to the contents of each box of its
operands, and boxes the result.  It is very fast.

The name 'each' is defined as &.> by the J startup code.
)
xxbb =: <"0 ] 5 - ? 100000 $ 10  NB. 100000 small boxes
NB. The following two lines have the same function but perform very differently:
20 ts '+:&.> xxbb'
ts '<@+:@> xxbb'
NB. The Conjunction u L:0 applies u at the lowest boxing level and is also fast:
20 ts '+: L:0 xxbb'

NB. &.> is so fast that it even runs faster than @> which doesn't have to
NB. box its result (it takes more space because its boxed result is much bigger):
20 ts '+:@> xxbb'

NB. ============================================================================
Lab Section The J Performance Monitor
Thge J Performance Monitor lets you probe your code to see what parts
are taking time.
)
NB. Load the application
load 'plot'
NB. Load the J Performance Monitor
load 'jpm'

NB. Now start timing
start_jpm_ 1e7

NB. Run the application here
plot 0 10;'sin'

NB. Turn off timing and view the result
0 0 85 showtotal_jpm_ ''
NB. Look inside a function
showdetail_jpm_ 'setplotdefaults_jwplot_'

NB. ============================================================================
Lab Chapter Parsing and Execution
NB. ============================================================================
Lab Section The Execution Model
Execution of a J sentence follows these steps:

1.  The sentence is broken into WORDS.  You can use ;: to show you what
  the words are.

2.  The words are considered as a STACK.  The stackpointer is
  initially pointing at the end of the stack.

3.  The four words starting with the stackpointer are examined to see if
  they match an executable pattern.  If they do, 2 or 3 of the words,
  depending on the pattern, are the executable FRAGMENT and are EXECUTED and
  then replaced by the result of the execution.  If not, the stackpointer
  is moved one position to the left.

4.  Step 3 is repeated until the stackpointer moves off the left-hand end of
  the sequence of words.

5.  If the stack contains one word, that is the result.  If there is more than
  one word, the sentence contains an error.
)

NB. ============================================================================
Lab Section The Parsing Table
The PARSING TABLE that gives the list of allowed executions is shown in
a new window.  Keep it visible for reference.

 stands for beginning-of-line, an extra word that is added at the
beginning of the sentence to act as a stopper.

A stands for Adverb, C for Conjunction, V for Verb, N for Noun.

name stands for any valid target name for an assignment.

The brackets [ ] do not stand for words in the input; they are used
in this version of the table to indicate the fragment that is executed and
replaced by the result of the execution.

The lines are examined in order.  A word matches if its type is one of
those listed for that position in that line.  When the four words at the
stackpointer all match, the line is matched: then the bracketed words are
EXECUTED, which gives a RESULT which is an entity, and that entity
replaces the bracketed words.

Executing a verb always produces a result which is a noun.  Executing a
modifier produces a result which can be any of the four principal parts of
speech.
)
SCRIPT
Word At Stackpointer    Word 1    Word 2    Word 3     Action
 =. =: (               [V        N]        anything   0 Monad
 =. =: ( A V N         V         [V        N]         1 Monad
 =. =: ( A V N         [N        V         N]         2 Dyad
 =. =: ( A V N         [V N      A]        anything   3 Adverb
 =. =: ( A V N         [V N      C         V N]       4 Conj
 =. =: ( A V N         [V N      V         V]         5 Fork
 =. =: (               [C A V N  C A V N]  anything   6 Hook/Adverb
[name N                 =. =:     C A V N]  anything   7 Is
[(                      C A V N   )]        anything   8 Paren
SCRIPT
PREPARE
(toHOST SCRIPT_jlab_) 1!:2 <jpath '~temp\parsetable.ijs'
PREPARE
open jpath '~temp\parsetable.ijs'

NB. ============================================================================
Lab Section Name or Value?
When the stackpointer is moved to point to a word, that word
is evaluated if it the name of a noun, an adverb, or a conjunction.
It is not evaluated if it is the name of a verb.

Since verbs and nouns can be passed as operands to modifiers, this means
that NOUNS are passed BY VALUE, while VERBS are passed BY NAME.

You usually can't tell the difference.
)
NB. Define an adverb that returns the representation of its operand as a noun:
lvalue =: 1 : '5!:5 <''u'' '
'abc' lvalue
+ lvalue
NB. Try it with a named verb operand
voper =: +
voper lvalue
NB. ...and with a noun operand
noper =: 1 2 3
noper lvalue

NB. Note that the noun was replaced by its value, but the verb was not.

NB. ============================================================================
Lab Section Following Execution using the trace facility
To follow parsing and execution, use the trace facility built into J.  Type

   load '~addons/general/misc/trace.ijs'

If the load fails, use jal to install general/misc addon.

This defines two verbs: trace and paren.  Each takes a y argument which is
a string containing the text of a J sentence.

paren y    returns the fully-parenthesized version of y

[x] trace y  gives you a detailed look at parsing and execution of the
           sentence y.  x is the maximum call depth to trace; we will
           be leaving it off, which will show everything.
)
load '~addons/general/misc/trace.ijs' NB. jal addon general/misc

paren 'i.&1-.3<+/i.5'  NB. A hard-to-read sentence

NB. ============================================================================
Lab Section Examples of Execution 1
We will follow the parsing and execution of a number of sentences of
increasing complexity.

The trace verb does not show the steps of moving the stackpointer, searching
for a match with a line of the parsing table.  It produces a set of output
lines when the stackpointer moves to a position that produces a match.  These
output lines begin with a line that starts with a string of dashes, for example

--------------- 3 Adverb -----

That first line, the one with the dashes, tells you which line of the
parse table was matched.  The bracketed part of that line of the parse table
identifies the fragment, the words that are going to be executed.

The next 3 or 4 lines are the fragment and the result.  The last line is the
result, and the preceding lines are the fragment.  After execution, the
words of the fragment are replaced by the single word of the result.

The first example is very simple: 2 + 3.   The pattern '2 + 3' matches line
2 of the parsing table, so the verb + is executed with left operand 2
and right operand 3.  This has the result 5, which replaces the 3 words
of the fragment on the stack.  There are no more matches, so the result of
the sentence is the value of the one word on the stack, 5.
)
trace '2 + 3'

NB. ============================================================================
Lab Section Examples of Execution 2
The next example is slightly more complex: (2 + 3)

The dyad line is the first match, again, with result 5.  Next, the line
for (5) is matched.  Note that 2 + 3 has been replaced, so the three
words (   5   ) are in consecutive stack positions.  The result of the
execution of (5) is 5, which becomes the final result.
)
trace '(2 + 3)'

NB. ============================================================================
Lab Section Examples of Execution 3
+/ 1 2 3

First, note that 1 2 3 is a single word for parsing purposes.

The first match is + /  which is the application of the adverb  /  to the
verb  +  .

The execution of + /  produces a verb which is a single word that replaces
the two words +  and  /  on the stack.

How is this verb indicated?  It has no name; it is an ANONYMOUS VERB.  The
important thing to see is that it is a single verb.  It is represented in the
trace by the string '+/', but that is just a way of telling you its function:
it may not invoke + at all during its execution.

An anonymous verb is DISPLAYED using a representation that could be used
to recreate the verb.  It may be EXECUTED any way the interpreter sees fit.
Consider the dyadic verb (i.&1)@:= .  If you look at the definition of the
components, you will think that each atom of x is compared with each atom
of y to produce a Boolean result, and then that Boolean list is searched to
find the first 1.  But think about it: this is just going to return the index
of the first item of x that is equal to the corresponding item of y.  There's
no need to compare any items after that first match has been found.  And
indeed, the interpreter is clever enough to stop after the first match.  That
is built into the operation of the anonymous verb.  That verb is displayed as
i.&1@:= , and it is guaranteed to produce the result described by that verb,
but how it does it is not specified.

After + /  is turned into the anonymous verb +/ , that verb is applied to
1 2 3 with the expected result.
)
trace '+/ 1 2 3'

NB. ============================================================================
Lab Section Examples of Execution 4
(3 1 $ 1 2 3) +/ . * (,: 1 2 3)

+/ . * is matrix multiplication, as defined under the . conjunction.

The first execution is ,: 1 2 3 as a monad to produce an array with shape 3 1,
followed by exexution of the surrounding parentheses.

The next executable pattern is   3 1  $  1 2 3 .  It is a useful exercise
to see why this is the first match (the fundamental reason is, if the
words to the left of +/ peoduced a conjunction, that conjunction would
have to be executed before any part of +/ . * ; so nothing can be executed
until the parenthesized bit has been executed and it is known what part
of speech it produces).

Next the +/ . * is executed, in two parts: + / , which produces an
anonymous verb represented as '+/', and then =/ . * which produces another
anonymous verb represented as '+/ .*' .

Finally, the anonymous verb '+/ .*' is executed as a dyad, to produces the
matrix product.

Note that there is only one verb execution, the final execution of '+/ .*' .
This verb does not invoke the * verb, or the code for + or +/ .  Matrix
multiplication is an important function, and it is handled with special
code that performs the operation as a unit.  The operation of +/ . * is
defined in terms of * and +, but how it is actually executed is the
interpreter's business.
)
trace '(3 1 $ 1 2 3) +/ . * (,: 1 2 3)'

NB. ============================================================================
Lab Section Examples of Execution 5
As a graphic demonstration of the fact that the derived verb is executed
as a verb only once, rather than having its parts executed, we take

5 7 9 11 13 ((+/ % #)@[ - (+/ % #)@]) 1 2 3

This takes the difference between the average value of the left operand
and the right operand.

One point of interest is the parsing of the fork:  +/ % #  is executed
as a fork (the rule is called 'Trident'), which is like the execution of a
conjunction: it produces an anonymous verb that represented the fork.

The result of all the executions of forks, adverbs, and conjunctions
produces a single anonymous verb that performs the entire function.
Then, at the very end, that function is executed.
)
trace '5 7 9 11 13 ((+/ % #)@[ - (+/ % #)@]) 1 2 3'

NB. ============================================================================
Lab Section Final Word
The message to take away from an examination of parsing is that when you
have compounds, the operands are not substituted into spots in the compounds
according to the definitions of the modifiers.  Rather, the compounds
create anonymous verbs that work on their operands according to those rules.

In other words,

  (+/ % #) y

is not executed as

  (+/ y) % (#y)

but it produces the same result as if it were.
)

NB. ============================================================================
Lab Chapter Plot Package
NB. ============================================================================
Lab Section Overview
The Plot Package lets you do fast 2D and 3D plots.

You give the Plot Package OPTIONS and DATA.  The options control
the display of the data, captioning, etc.

The very fastest plot uses the plot verb.
)
load 'plot'
plot *: i. 20  NB. Just the y values.  X is assumed to be integers.

NB. ============================================================================
Lab Section 2D Line Plots
You can give both x and y values.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
plot x ; sin x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section 2D Point Plots
You can plot points rather than lines.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
'point;pensize 3' plot x ; sin x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section Plots With More Than One Ordinate
You can plot more than one curve on the same plot.
)
require 'plot'
require 'trig'
x =: 50 %~ o. i. 100  NB. 100 values of x from 0 to 2p1
plot x ; (sin ,: cos) x  NB. abscissas ; ordinates

NB. ============================================================================
Lab Section Function Plots
You can plot functions.  Plot will automatically skip over discontinuities.
)
plot _5 5 ; '% y'  NB. domain ; function (reciprocal)

NB. ============================================================================
Lab Section Mixing Plot Types
For more complex plots, you use the pd verb.  pd sends options, data, and
COMMANDS to the Plot Package.  The commands start and display or print the
plot.
)
require 'plot'
require 'trig'
pd 'reset'  NB. Start new plot
pd 'type line; color red'  NB. Start line plot
pd 0 2p1 ; 'sin'  NB. Plot sin function
pd 'type point;pensize 3;color green'  NB. Start dot plot
pd 0 2p1 ; 'cos'  NB. plot cos function as dots
pd 'show'  NB. Show combined plot

NB. ============================================================================
Lab Section Parametric plots
y does not have to be a function of x.
)
require 'plot'
require 'trig'
t =: 50 %~ o. i. 201  NB. 100 values of x from 0 to 2p1
plot (sin t) ; cos 1.5 * t  NB. Parametric function

NB. ============================================================================
Lab Section Surface plots
3D datasets can be plotted either as surfaces or as 3D lines.
)
require 'plot'
require 'trig'
dat=. (];];sin@*/~) i:2j70  NB. x ; y ; sin(x*y) from _2 to 2
pd 'reset'
pd 'type surface'
pd 'edgecolor 64 64 64'
pd 'backcolor lightgray'
pd dat
pd 'show'

NB. ============================================================================
Lab Section Wireframe plots
)
require 'plot'
require 'trig'
dat=. (];];sin@*/~) i:2j70  NB. x ; y ; sin(x*y) from _2 to 2
pd 'reset'
pd 'type wire'
pd 'edgecolor 64 64 64'
pd 'backcolor lightgray'
pd dat
pd 'show'

NB. ============================================================================
Lab Section L'envoi
Plot has a great many other bells and whistles: annotation, other types
of plot, multiple plots arrayed in the same window, and more.
)

NB. ============================================================================
Lab Chapter Grid Control
NB. ============================================================================
Lab Section Overview
The Grid Control is a class that connects a rank-2 array to an
isigraph control, where it displays the array and allows editing.
It it like a spreadsheet whose contents are a J noun.
)
NB. The simplest way to use Grid is the grid verb, which creates a form
NB. and then displays its operand in it:
require 'grid'
grid USERFOLDERS_j_

NB. ============================================================================
Lab Section Displaying a Grid in a Form
To make full use of the Grid Control as an interactive interface
to data, you create a form with an isigraph, connect the isigraph to
the Grid Control, pass your data to the Grid Control, and show the form.
)
require 'grid'

NB. Form definition
GRIDEX=: 0 : 0
pc gridex;
xywh 0 0 200 200;cc grid isigraph rightmove bottommove;
pas 0 0;ptop;pmove 217 113 215 220;
rem form end;
)

NB. Cancel methods for the form
destroy_gridex =: 3 : 0
wd'pclose'
destroy__grid''
)
gridex_cancel=: gridex_close=: destroy_gridex

3 : 0 ''
NB. Create the form
if. wdisparent 'gridex' do. psel 'gridex' else.
  wd GRIDEX
  NB. Create the grid
  grid=: '' conew 'jzgrid'
end.

NB. Send data to the grid
hdr =. 'HDRCOL' ,&< 'Name';'Path';'Sub'
hdr =. hdr , ('CELLALIGN';0 0 2) ,: ('CELLEDIT';0)
show__grid hdr , ('GRIDSORT' ; 1) ,: 'CELLDATA' ;< USERFOLDERS_j_
wd 'pn *User Folders'

NB. Show the form
wd 'pshow'
)

NB. ============================================================================
Lab Section Grid Events
When an isigraph is under the control of grid, window events for the isigraph
are normally handled by grid.  (You can handle them yourself if you want,
but that's extra work).

Most of the events that you might be interested in are preprocessed by the
Grid Control and then offered to you.  You take action if you want to,
and you return to the Grid Control telling it whether it should proceed with
its own processing for the event.

The way you do this is by defining a gridhandler verb.  This verb will
be called by Grid, with y indicating the type of event, and with other globals
set with useful information about the event.
)
NB. Here is a gridhandler that simply displays the type of event and then
NB. lets the Grid Control continue:
grid_gridhandler =: 3 : 0
smoutput y
1
)

NB. Display the grid again.  Events will be noted in the .ijx window
require 'grid'

NB. Form definition
GRIDEX=: 0 : 0
pc gridex;
xywh 0 0 200 200;cc grid isigraph rightmove bottommove;
pas 0 0;ptop;pmove 217 113 215 220;
rem form end;
)

NB. Cancel methods for the form
destroy_gridex =: 3 : 0
wd'pclose'
destroy__grid''
)
gridex_cancel=: gridex_close=: destroy_gridex

3 : 0 ''
NB. Create the form
if. wdisparent 'gridex' do. psel 'gridex' else.
  wd GRIDEX
  NB. Create the grid
  grid=: '' conew 'jzgrid'
end.

NB. Send data to the grid
hdr =. 'HDRCOL' ,&< 'Name';'Path';'Sub'
hdr =. hdr , ('CELLALIGN';0 0 2) ,: ('CELLEDIT';0)
show__grid hdr , ('GRIDSORT' ; 1) ,: 'CELLDATA' ;< USERFOLDERS_j_
wd 'pn *User Folders'

NB. Show the form
wd 'pshow'
)

NB. ============================================================================
Lab Chapter Writing Modifiers
NB. ============================================================================
Lab Section Two Kinds of Modifiers
You create modifiers with 1 : (for an adverb) or 2 : (for a conjunction).

There are two broad classes of modifiers.

The PATTERN MODIFIERS are used to express a template for the application
of different verbs.  When such a modifier is given its u/v operands, it
produces an entity that has the operands inserted into the pattern.
The entity is usually a verb, but it need not be.
This kind of modifier does not refer to x or y operands.

The LATENT MODIFIERS refer to x or y, and produce only verbs.  Such a
modifier is an ordinary explicit verb that needed another operand or two,
either because two noun operands were not enough or because some of the
operands are verbs.  When such a modifier is given its u/v operands,
those operands are saved and made part of a complex that includes the
operands and the definition of the modifier.  This complex is necessarily
a verb, and it is executed when it is given x/y operands.  The saved values
of u/v are only then used by the definition, which is why such modifiers
are called 'latent'.
)

NB. ============================================================================
Lab Section Pattern Modifiers
Pattern modifiers are the way you produce templates of sequences that
occur repeatedly in your code.
)
odisp =: 9!:2''
9!:3 (5)   NB. Set only linear display
NB. Examples of pattern modifiers
NB. Note that when a pattern modifier is given its u/v operands, it
NB. immediately executes its definition and produces a (usually verb)
NB. entity

NB. Conjunction: u unless y is empty; then v
butifnull =: 2 : 'v"_`u@.(*@#@])'
+ butifnull 0

NB. Adverb.  Do u, but skip it if y is null
ifany =: ^: (*@#@])
+ ifany

NB. Adverb.  Apply u and join the results end to end
endtoend =: 1 : ';@:(<@u)'
i."0 endtoend
i."0 endtoend 1 2 3 4

NB. Conjunction for readability.  x u ux_vy v y  is  (u x) v y
ux_vy =: 2 : '(v~ u)~'
+ ux_vy -

NB. m is name of noun; n is default value; result is the value of
NB. the noun if it is defined, otherwise n
butifundef =: 2 : 'if. 0 > 4!:0 <m do. n else. ". m end.'
defname =: 5
'defname' butifundef 0
'undefname' butifundef 0

NB. ============================================================================
Lab Section Latent Modifiers
A latent modifier is just an explicit verb with extra operands.  When the
modifier is executed, the text of the definition is not examined.  Instead,
a derived verb is produced, comprising the text of the definition and the
u/v operands.  When this verb is given x/y operands, the text of the definition
is executed as a verb.

Like all explicit verb, a latent modifier has monadic and dyadic forms,
separated in the definition by a line contining only a : character.
)
9!:3 odisp   NB. restore display
NB. Conjunction.  Apply u at the cell indicated by n
applyintree =: 2 : 0
if. #n do. ((u applyintree (}.n)) L:_1 ({.n){y) ({.n)} y else. u y end.
:
NB. The rank is s,0 where s is the surplus of x-rank over y-rank.  This causes
NB. the cells of y to be matched up with the largest appropriate blocks x  This
NB. is necessary because it is impossible to change the shape of the values being modified
if. #n do. (x u applyintree (}.n) L:_ _1"(0 (,~ >.) x -&(#@$) a) (a =. ({.n){y)) ({.n)} y else. x u y end.
)
>: applyintree (1;2)  NB. This generates a complex, containing the definition
]a =: 1 ; (2 ; 3 ; 4) ;< (5 ; 6)   NB. y operand
>: applyintree (1;2) a   NB. This executes the definition

NB. ============================================================================
Lab Section Prefer Pattern Modifiers Where Possible
If you have a choice between writing a pattern modifier or a latent modifier,
choose the pattern modifier.  It will be interpreted only once, at the
time it is defined.  A latent modifier is interpreted for every cell it
is executed on.
)

