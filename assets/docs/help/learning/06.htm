<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
    
<HTML> 
<HEAD> 
  <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=ISO-8859-1"> 
  <META NAME="GENERATOR" CONTENT="OpenOffice.org 1.9.118  (Win32)"> 
  <META NAME="CREATED" CONTENT="20051014;16001218"> 
	<META NAME="CHANGED" CONTENT="20051014;16020434"> 
  <title>   Ch 6: Indexing</title> 
  <STYLE TYPE="text/css"> 
   <!-- 
    TT  {font-size: 11pt; COLOR: BLUE} 
    PRE {font-size: 11pt; COLOR: BLUE} 
   --> 
  </STYLE>
</HEAD>
          
<BODY BGCOLOR=WHITE><!--top jump start--><a href="07.htm">&gt;&gt;</a>&nbsp;
<a href="05.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<hr><!--top jump end--> 
  <table border="0" cellpadding="5" cellspacing="0"  width="100%"> 
  <tr> <td valign="top" width="17%"> <p> </td> 
   <td valign="top" width="83%"> 
 <A NAME="01"></A>
<H1>Chapter 6: Indexing</H1>
Indexing is the name given to selecting of elements of arrays by position. 
This topic 
includes selecting elements, rearranging selected elements to form new arrays, 
and amending, or updating, selected elements of arrays. 
<A NAME="02"></A>
<H2>6.1  Selecting</H2>
The verb <TT>{</TT> (left-brace) is called "From".  The expression <TT>(x { y)</TT> 
selects elements from <TT>y</TT> according to positions given by <TT>x</TT>.  For example, recall 
from <A HREF="02.htm">Chapter 02</A> that if <TT>L</TT> is a list, then the positions of items 
of <TT>L</TT> are numbered 0 1 and so on.  The expression <TT>(0 { L)</TT> gives the value of the first 
item of <TT>L</TT> and <TT>1 { L</TT> gives the second item.   
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L =: 'abcdef'</TT></TD>
<TD><TT> 0 { L</TT></TD>
<TD><TT> 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a</TT></TD>
<TD><TT>b</TT></TD>
</TABLE>
<p>
The left argument of <TT>{</TT> is called the "index".
<H3>6.1.1  Common Patterns of Selection.</H3>
Several items may be selected together:  
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT>0 2 4 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ace</TT></TD>
</TABLE>
<p>
Items selected from <TT>L</TT> may be replicated and re-ordered:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT>5 4 4 3 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>feed</TT></TD>
</TABLE>
<p>
An index value may be negative: a value of <TT>_1</TT> selects the last item, <TT>_2</TT> selects the 
next-to-last item and so on. Positive and negative indices may be mixed.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT> _1 { L</TT></TD>
<TD><TT> _2 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>eb</TT></TD>
</TABLE>
<p>
A single element of a table at, say, row 1 column 2
is selected with an index <TT>(&lt; 1 ; 2)</TT>.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>T =: 3 3 $ 'abcdefghi'</TT></TD>
<TD><TT> (< 1 ; 2) { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>f</TT></TD>
</TABLE>
<p>
We can select from a table all elements in specified rows and columns, to produce a 
smaller table (called a subarray).  To select a subarray consisting of, for example rows 
<TT>1</TT> and <TT>2</TT> and columns <TT>0</TT> and <TT>1</TT>, we use an index <TT>(&lt; 1 2; 0 1)</TT>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>T</TT></TD>
<TD><TT>(< 1 2;0 1) { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>de<BR>
gh</TT></TD>
</TABLE>
<p>
A complete row or rows may be selected from a table. Recall that a table is a list of items, each 
item being a row. Thus selecting rows from tables is just like selecting items from lists. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>T </TT></TD>
<TD><TT>1 { T</TT></TD>
<TD><TT>2 1 { T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>def</TT></TD>
<TD><TT>ghi<BR>
def</TT></TD>
</TABLE>
<p>
To select a complete column or columns,
a straightforward way is
to select all the rows:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>T </TT></TD>
<TD><TT>(< 0 1 2 ; 1 ){ T</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def<BR>
ghi</TT></TD>
<TD><TT>beh</TT></TD>
</TABLE>
<p>
but there are other possibilities: see below.
<A NAME="03"></A>
<H3>6.1.2  Take, Drop, Head, Behead, Tail, Curtail</H3>
Next we look at a group of verbs providing 
some convenient short forms of indexing.
There is a built-in verb <TT>{.</TT> (left brace dot,  
called "Take"). 
The first <TT>n</TT> items of list <TT>L</TT> are selected by 
<TT>(n {. L)</TT> 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>2 {. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ab</TT></TD>
</TABLE>
<p>
If we take <TT>n</TT> items from <TT>L</TT> with
<TT>(n {. L)</TT>,
and <TT>n</TT> is greater than the length of <TT>L</TT>,
the result is padded to length <TT>n</TT>, with zeros, spaces or 
empty boxes as appropriate. 
<p>
For example, suppose
we require to make a string of exactly 8 characters
from a given string, a description of some kind, which may
be longer or shorter than 8. If longer, we shorten. 
If shorter we pad with spaces.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>s =: 'pasta'</TT></TD>
<TD><TT># s</TT></TD>
<TD><TT>z =: 8 {. s</TT></TD>
<TD><TT># z</TT></TD>
<TR VALIGN=TOP>
<TD><TT>pasta</TT></TD>
<TD><TT>5</TT></TD>
<TD><TT>pasta&nbsp;&nbsp;&nbsp;</TT></TD>
<TD><TT>8</TT></TD>
</TABLE>
<p>
<A NAME="04"></A>
There is a built-in verb <TT>}.</TT> 
(right-brace dot, called "Drop").
All but the first <TT>n</TT> items of <TT>L</TT> are selected by
<TT>(n }. L)</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>2 }. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>cdef</TT></TD>
</TABLE>
<p>
The last <TT>n</TT> items of <TT>L</TT> are selected by 
<TT>(-n) {. L</TT>. 
All but the last <TT>n</TT> are selected by 
<TT>(-n) }. L</TT>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>_2 {. L</TT></TD>
<TD><TT>_2 }. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ef</TT></TD>
<TD><TT>abcd</TT></TD>
</TABLE>
<p>
<A NAME="05"></A>
<A NAME="06"></A>
There are abbreviations of Take and Drop in
the special case where <TT>n=1</TT>. 
The first item of a list is selected by monadic <TT>{.</TT>
(left-brace dot, called "Head").  All but the first
are selected by <TT>}.</TT> (right-brace dot, called "Behead").
<A NAME="07"></A>
<A NAME="08"></A>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>{. L</TT></TD>
<TD><TT>}. L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a</TT></TD>
<TD><TT>bcdef</TT></TD>
</TABLE>
<p>
The last item of a list is selected by monadic <TT>{:</TT>
(left-brace colon, called "Tail").  All but the last
are selected by <TT>}:</TT> (right-brace colon, called "Curtail".
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>{: L</TT></TD>
<TD><TT>}: L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>abcde</TT></TD>
</TABLE>
<p>
<H2>6.2  General Treatment of Selection</H2>
It will help to have some terminology.  In general we will have an n-dimensional array, 
but consider a 3-dimensional array.  A single element is picked out by giving a plane-
number, a row-number and a column-number.  We say that the planes are laid out in 
order along the first axis, and similarly the rows along the second axis, and 
the columns along the third. 
<p>
There is no special notation for indexing; rather the left argument of <TT>{</TT> is 
a data structure which expresses, or encodes, selections and 
rearrangements. This data structure can be built in any way convenient. What follows 
is an explanation of how to build it.
<H3>6.2.1  Independent Selections</H3>
The general expression for indexing is of the form <TT>index { array</TT>. Here <TT>index</TT>
is an array of scalars. Each scalar in <TT>index</TT> gives rise to a separate
independent selection, and the results are assembled together. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L </TT></TD>
<TD><TT> 0 1 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>ab</TT></TD>
</TABLE>
<p>
<H3>6.2.2  Shape of Index</H3>
The shape of the results depends on the shape of <TT>index</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>index =: 2 2 $ 2 0 3 1</TT></TD>
<TD><TT>index { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>2 0<BR>
3 1</TT></TD>
<TD><TT>ca<BR>
db</TT></TD>
</TABLE>
<p>
The indices must lie within the range <TT>-#L</TT> to <TT>(#L)-1</TT>:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT> L</TT></TD>
<TD><TT>#L</TT></TD>
<TD><TT>_7 { L</TT></TD>
<TD><TT>6 { L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>6</TT></TD>
<TD><TT>error</TT></TD>
<TD><TT>error</TT></TD>
</TABLE>
<p>
<H3>6.2.3  Scalars</H3>
Each scalar in <TT>index</TT> is either a single number or a box (and of course if one is a box, all are.)
If the scalar is a single number it selects an item 
from <TT>array</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A =: 2 3 $ 'abcdef'</TT></TD>
<TD><TT>1 { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If the scalar in <TT>index</TT> is a box however then it contains a list of selectors which are applied to successive axes.
To show where a box is used for this purpose, we can use the name <TT>SuAx</TT>, say, for the box function.
<PRE>
   SuAx =: <
</PRE>
The following example selects from <TT>A</TT> the element at row 1, column 0. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx 1 0) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>d</TT></TD>
</TABLE>
<p>
<H3>6.2.4  Selections on One Axis</H3>
In a list of selectors for successive axes, of the form <TT>(SuAx p , r, c)</TT> say,
each of <TT>p</TT>, <TT>r</TT> and <TT>c</TT> is a scalar. 
This scalar is either a number or a box (and if one is boxed, all are).
A number selects one thing on its axis: one plane, row or column as appropriate, as in the last example.
<p>
However, if the selector is a box it contains a list of selections all applicable to the same
axis. To show where a box is used for this purpose we can use the name <TT>Sel</TT>, say, for the box function.
<PRE>
   Sel =: <
</PRE>
For example, to select from <TT>A</TT> elements at row 1, columns 0 2:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1), (Sel 0 2)) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>df</TT></TD>
</TABLE>
<p>
<H3>6.2.5  Excluding Things</H3>
Instead of selecting things on a particular axis, we can exclude things, by supplying a list of
thing-numbers enclosed in yet another level of boxing.
To show where a box is used for this purpose we can use the name <TT>Excl</TT>, say, for the box function.
<PRE>
   Excl =: <
</PRE>
For example, to select from <TT>A</TT> elements at row 0, all columns excluding column 1:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 0), (Sel (Excl 1))) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>ac</TT></TD>
</TABLE>
<p>
We can select all things on a particular axis by excluding nothing, that is, giving an empty
list <TT>(0$0)</TT> as a list of thing-numbers to exclude.
For example, to select from <TT>A</TT> elements at row 1, all columns:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel (Excl 0$0))) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
<A NAME="09"></A>
<H3>6.2.6  Simplifications</H3>
The expression <TT>(Excl 0$0)</TT> denotes a boxed empty
list. There is a built-in J abbreviation for this,
namely <TT>(a:)</TT> (letter-a colon, called "Ace"), which in this context we can think of as meaning "all".
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel a:)) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If in any index of the form <TT>(SuAx p,q,..., z)</TT>,
 the last selector <TT>z</TT> is the "all" form, 
<TT>(Sel (Excl 0$0))</TT> or <TT>(Sel a:)</TT>,
 then it can be omitted.
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel a:)) {A</TT></TD>
<TD><TT>(SuAx (Sel 1)) {A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>def</TT></TD>
<TD><TT>def</TT></TD>
</TABLE>
<p>
If in any index of the form 
<TT>(SuAx (Sel p),(Sel q),...)</TT>, the "all" form is entirely absent,
then the index can be abbreviated to <TT>(SuAx p;q;...)</TT>. For example, to select elements at
row 1, columns 0 and 2:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT>(SuAx (Sel 1),(Sel 0 2)) {A</TT></TD>
<TD><TT>(SuAx 1;0 2) {A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>df</TT></TD>
<TD><TT>df</TT></TD>
</TABLE>
<p>
Finally, as we have already seen, if selecting only one thing on each axis, a simple unboxed list is sufficient. 
For example to select  the element at row 1, column 2:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A </TT></TD>
<TD><TT>(SuAx 1;2) { A</TT></TD>
<TD><TT>(SuAx 1 2) { A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>f</TT></TD>
<TD><TT>f</TT></TD>
</TABLE>
<p>
<H3>6.2.7  Shape of the Result</H3>
Suppose that <TT>B</TT> is a 3-dimensional array:
<PRE>
   B =: 10 + i. 3 3 3
</PRE>
and we define <TT>p</TT> to select planes along the first axis 
of <TT>B</TT>,
and <TT>r</TT> to select rows along the second axis, and <TT>c</TT> 
to select columns along the third axis:
<PRE>
   p =: 1 2
   r =: 1 2
   c =: 0 1
</PRE>
We see that, selecting with <TT>p;r;c</TT>, the shape of the result
<TT>R</TT> is the concatenation of the shapes of <TT>p</TT>, <TT>r</TT> and <TT>c</TT>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>B</TT></TD>
<TD><TT>R =: (< p;r;c) { B</TT></TD>
<TD><TT>$ R</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>10 11 12<BR>
13 14 15<BR>
16 17 18<BR>
<BR>
19 20 21<BR>
22 23 24<BR>
25 26 27<BR>
<BR>
28 29 30<BR>
31 32 33<BR>
34 35 36</TT></TD>
<TD><TT>22 23<BR>
25 26<BR>
<BR>
31 32<BR>
34 35</TT></TD>
<TD><TT>2 2 2</TT></TD>
<TD><TT>2 2 2</TT></TD>
</TABLE>
<p>
<TT>B</TT> is 3-dimensional, and so is <TT>R</TT>. As we would expect, 
this concatenation-of-shapes holds 
when a selector (<TT>r</TT>, say) is a list of length one:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>r =: 1 $ 1</TT></TD>
<TD><TT>S =: (< p;r;c){B</TT></TD>
<TD><TT>$ S</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>1</TT></TD>
<TD><TT>22 23<BR>
<BR>
31 32</TT></TD>
<TD><TT>2 1 2</TT></TD>
<TD><TT>2 1 2</TT></TD>
</TABLE>
<p>
and the concatenation-of-shapes holds 
when selector <TT>r</TT> is a scalar:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>r =: 1</TT></TD>
<TD><TT>T =: (< p;r;c){B</TT></TD>
<TD><TT>$ T</TT></TD>
<TD><TT>($p),($r),($c)</TT></TD>
<TD><TT>$ r</TT></TD>
<TR VALIGN=TOP>
<TD><TT>1</TT></TD>
<TD><TT>22 23<BR>
31 32</TT></TD>
<TD><TT>2 2</TT></TD>
<TD><TT>2 2</TT></TD>
<TD><TT>&nbsp;</TT></TD>
</TABLE>
<p>
In this last example, <TT>r</TT> is a scalar, so the shape of 
<TT>r</TT> is an empty list, and so the axis corresponding to <TT>r</TT>
has disappeared, and so the result <TT>T</TT> is 2-dimensional.
<A NAME="10"></A>
<A NAME="11"></A>
<H2>6.3  Amending (or Updating)  Arrays</H2>
Sometimes we need to compute an array which is the same as an existing array except 
for new values at a comparatively small number of positions. We may speak of 
'updating' or 'amending' an array at selected positions.  The J function for amending 
arrays is <TT>}</TT> (right brace, called "Amend"). 
<H3>6.3.1  Amending with an Index</H3>
To amend an array we need three things:
<UL>
<LI> the original array
<LI> a specification of the position(s) at which the original is to be amended. This can be 
an index exactly like the index we have seen above for selection with <TT>{</TT>.
<LI> new values to replace existing elements at specified positions.
</UL>
Consequently the J expression to perform an amendment 
may have the general form:
<PRE>
        newvalues index } original
</PRE>
For example:  to amend list <TT>L</TT> to replace the first item (at index <TT>0</TT>) with '*':
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>L</TT></TD>
<TD><TT>new=:'*'</TT></TD>
<TD><TT>index=:0</TT></TD>
<TD><TT>new index } L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>*</TT></TD>
<TD><TT>0</TT></TD>
<TD><TT>*bcdef</TT></TD>
</TABLE>
<p>
<TT>}</TT> is an adverb, which 
takes <TT>index</TT> as its argument to yield the dyadic amending verb <TT>(index })</TT>. 
<PRE>
   ReplaceFirst =: 0 }
   '*' ReplaceFirst L
*bcdef
</PRE>
<TT>(index })</TT> is a verb like any other, dyadic and yielding a value in the usual way. 
Therefore to change an array by amending needs the whole of the result to be 
reassigned to the old name.  Thus amendment often takes place on the pattern:
<PRE>
                 A  =:  new index } A 
</PRE>
The J system ensures that this is an efficient computation with no
unnecessary movement of data.
<p>
To amend a table at row 1 column 2, for example:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>A</TT></TD>
<TD><TT> '*' (< 1 2) } A</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abc<BR>
def</TT></TD>
<TD><TT>abc<BR>
de*</TT></TD>
</TABLE>
<p>
To amend multiple elements, a list of new values can be supplied, and they are taken 
in turn to replace a list of values selected by an index
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT> L</TT></TD>
<TD><TT> '*#' 1 2 } L</TT></TD>
<TR VALIGN=TOP>
<TD><TT>abcdef</TT></TD>
<TD><TT>a*#def</TT></TD>
</TABLE>
<p>
<H3>6.3.2  Amending with a Verb</H3>
Suppose that <TT>Y</TT> is a list of numbers, and we wish to amend it so that all numbers exceeding
a given value <TT>X</TT> are replaced by <TT>X</TT>. 
(For the sake of this
example, we here disregard the built-in J verb 
 <TT>(&lt;.)</TT> for this function.)
<p>
The indices at which <TT>Y</TT> is to be amended must 
be computed from <TT>X</TT> and <TT>Y</TT>.  
Here is a function <TT>f</TT> to compute the indices:
<PRE>
   f =: 4 : '(y > x) # (i. # y)'
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>X =: 100</TT></TD>
<TD><TT>Y =: 98 102 101 99</TT></TD>
<TD><TT>Y > X</TT></TD>
<TD><TT>X f Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>100</TT></TD>
<TD><TT>98 102 101 99</TT></TD>
<TD><TT>0 1 1 0</TT></TD>
<TD><TT>1 2</TT></TD>
</TABLE>
<p>
The amending is done, in the way we have seen above,
 by supplying indices of <TT>(X f Y)</TT>:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>Y</TT></TD>
<TD><TT>X (X f Y) } Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>98 102 101 99</TT></TD>
<TD><TT>98 100 100 99</TT></TD>
</TABLE>
<p>
The "Amend" adverb <TT>}</TT> allows the expression 
<TT>(X (X f Y) } Y)</TT>
to be abbreviated as <TT>(X f } Y)</TT>. 
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>X (X f Y) } Y</TT></TD>
<TD><TT>X f } Y</TT></TD>
<TR VALIGN=TOP>
<TD><TT>98 100 100 99</TT></TD>
<TD><TT>98 100 100 99</TT></TD>
</TABLE>
<p>
Since <TT>}</TT> is an adverb, it can accept
as argument either the indices <TT>(X f Y)</TT> or the verb <TT>f</TT>.
<PRE>
   cap =: f }
   
   10 cap 8 9 10 11
8 9 10 10
</PRE>
Note that if verb <TT>f</TT> is to be supplied as argument
to adverb <TT>}</TT>, then <TT>f</TT> must be a dyad, although
it may ignore <TT>X</TT> or <TT>Y</TT>. 
<A NAME="12"></A>
<H3>6.3.3  Linear Indices</H3>
We have just looked at amending lists with a verb. The purpose of the verb is to find 
the places at which to amend, that is, to compute from the values in a list the indices at 
which to amend. With a table rather than a list, the indices would have to be  2-
dimensional, and the task of the verb in constructing the indices would be 
correspondingly more difficult.  
It would be easier to flatten a table into a linear list,  
amend it as a list, and rebuild the list into a
 table again.  
<p>
For example, suppose we have a table:
<PRE>
   M =: 2 2 $ 13 52 51 14
</PRE>
Then, using our index-finding verb <TT>f</TT>, 
the flattening, amending and rebuilding is shown by:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>LL =: ,M</TT></TD>
<TD><TT>Z =: 50 f } LL</TT></TD>
<TD><TT> ($M) $ Z</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 52 51 14</TT></TD>
<TD><TT>13 50 50 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
However, there is a better way.
First note that our index-finding verb <TT>f</TT> takes as argument, not <TT>M</TT>
but <TT>(LL =: , M)</TT>. Thus information about the original shape of <TT>M</TT>
is not available to the index-finder <TT>f</TT>. 
In this example, this does not matter, but in general
we may want the index-finding to depend upon both the shape and the 
values in <TT>M</TT>. It would be better
if <TT>f</TT> took the whole of <TT>M</TT> as argument.
In this case <TT>f</TT> must do its own flattening.
Thus we redefine <TT>f</TT>:
<PRE>
   f =: 4 : 0
y =. , y
(y > x) # (i. # y)
)
   
</PRE>
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>50 f M</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>1 2</TT></TD>
</TABLE>
<p>
Now the index finder <TT>f</TT> takes an array as 
argument,
and delivers indices into the flattened array, so-called "linear indices".
The amending process, with this new <TT>f</TT>, is shown by:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>($M) $ 50 (50 f M) } (, M)</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
Finally, provided <TT>f</TT> delivers linear indices, then <TT>(})</TT> allows
the last expression to be abbreviated as:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>M</TT></TD>
<TD><TT>50 f } M</TT></TD>
<TR VALIGN=TOP>
<TD><TT>13 52<BR>
51 14</TT></TD>
<TD><TT>13 50<BR>
50 14</TT></TD>
</TABLE>
<p>
<A NAME="13"></A>
<H2>6.4  Tree Indexing</H2>
So far we have looked at indexing into rectangular arrays.
There is also a form of indexing into boxed structures,
which we can picture as "trees" having branches and leaves.
For example:
<PRE>
   branch =: <
   leaf   =: <
   
   branch0 =: branch (leaf 'J S'),(leaf 'Bach')
   branch1 =: branch (leaf 1), (leaf 2), (leaf 1777)
   tree    =: branch0,branch1
   tree
+----------+----------+
|+---+----+|+-+-+----+|
||J S|Bach|||1|2|1777||
|+---+----+|+-+-+----+|
+----------+----------+
</PRE>
Then data can be fetched from the tree 
by specifying a path from the root. The path is 
a sequence of choices,
given as left argument to the verb <TT>{::</TT> 
(left-brace colon colon,called "Fetch")
The path <TT>0</TT> will fetch the first branch, while
the path <TT>0;1</TT> fetches the second leaf of the first branch:
<p>
<TABLE CELLPADDING=10 BORDER=1>
<TR  VALIGN=TOP>
<TD><TT>0 {:: tree</TT></TD>
<TD><TT>(0;1) {:: tree</TT></TD>
<TR VALIGN=TOP>
<TD><TT>+---+----+<BR>
|J S|Bach|<BR>
+---+----+</TT></TD>
<TD><TT>Bach</TT></TD>
</TABLE>
<p>
The monadic form <TT>{:: tree</TT> is called the 
"Map" of <TT>tree</TT>.
it has the same boxed structure as <TT>tree</TT> and 
shows the path to each leaf.
<PRE>
   {:: tree
+-------------+-------------------+
|+-----+-----+|+-----+-----+-----+|
||+-+-+|+-+-+|||+-+-+|+-+-+|+-+-+||
|||0|0|||0|1|||||1|0|||1|1|||1|2|||
||+-+-+|+-+-+|||+-+-+|+-+-+|+-+-+||
|+-----+-----+|+-----+-----+-----+|
+-------------+-------------------+
</PRE>
This is the end of Chapter 6.
  </tr> </table> 
<HR>  
 <p ALIGN=CENTER> 
 <A HREF="07.htm"> NEXT </A> <BR> 
 <A HREF="contents.htm#toc"> Table of Contents </A> <BR> 
<A HREF="kwic.htm"> Index </A> 
<HR> 
<P ALIGN=CENTER> 
<FONT SIZE=-1>The examples in this chapter 
were executed using J version  j701/beta/2010-11-24/22:45. 
 This chapter last updated 22 Dec 2010<BR> 
Copyright &copy; Roger Stokes 2010. 
 This material may be freely reproduced, 
provided that this copyright notice is also reproduced. 
</FONT> 
 <!--bottom jump start--><hr><a href="07.htm">&gt;&gt;</a>&nbsp;
<a href="05.htm">&lt;&lt;</a>&nbsp;
<a href="../user/contents.htm">Usr</a>&nbsp;
<a href="../primer/contents.htm">Pri</a>&nbsp;
<a href="../jforc/contents.htm">JfC</a>&nbsp;
<a href="../learning/contents.htm">LJ</a>&nbsp;
<a href="../phrases/contents.htm">Phr</a>&nbsp;
<a href="../dictionary/contents.htm">Dic</a>&nbsp;
<a href="../release/contents.htm">Rel</a>&nbsp;
<a href="../dictionary/vocabul.htm">Voc</a>&nbsp;
<a href="../dictionary/xmain.htm">!:</a>&nbsp;
<a href="../index.htm">Help</a>&nbsp;
Learning J<!--bottom jump end--></BODY> 
 </HTML> 
 
